==Easy Dialog==

Третья версия интерпретатора диалогов. Концептуально сильно отличается от версии 1. Версия 2 так и не была дописана, поэтому нет смысла искать какой-либо промежуточный вариант.

В третьей версии было решено отделить непосредственно генератор диалогов от интерпретатора. Интерпретатор по прежнему реализуется на QSP, в то время как генератор ввиду того, что очень тяжёл и использует множество циклов, выделен в отдельный python-script.

Правила написания исходных текстов для диалогов по сравнению с первой версией не изменились, изменились лишь некоторые настройки, о чём подробно будет написано ниже.

Так же третья версия теперь требует работы с модулем "easy.database", дабы всё в игре было увязано в единую базу данных.

=Структура Таблицы Диалогов=

Таблица Диалогов — это упрощённое название таблицы данных, в которой размещаются некоторые виды объектов, необходимых для реализации диалога.

=Объекты=

--Диалог--

По сути диалог — это корневая реплика без текста. Эта реплика может содержать в себе список необходимых ролей, а так же другие реплики и объекты диалога.

--Реплики--

Бывают двух типов: пассивные (Questions) и активируемые (Answers). Пассивные реплики как правило отдаются персонажам, с которыми взаимодействует игрок, в то время, как активируемые реплики — являются вариантами выбора, из которых игроку предложено выбирать.

Так же реплики могут обладать различными настройками, например, к ним может быть привязана роль.

--Роли--

Объект роль описывает, как выглядит реплика от данного персонажа при выводе на экран. Поскольку мы имеем дело с двумя типами реплик, описывать необходимо оба типа для каждой роли.

=Наследование, каскадность=

По идее нам нужна такая структура диалогов, при которой мы можем не дублировать одни и те же фрагменты диалогов в отдельных диалогах, а подключать их, как отдельные универсальные ветки. При этом реплики в таких ветках должны назначаться ролям, указанным в ссылающихся на них диалогах.

Мы должны иметь возможность создавать роли на базе уже существующих ролей так же, как с каскадным наследованием настроек в первой версии. Однако при этом есть сложность, так как для разных игр структура ролей может различаться.

Как вариант, использовать динамический код, чтобы генерировать обёртку реплики в соответствии с ролью. Например, такой динамический код может получить в качестве аргумента идентификатор роли в таблице данных и извлечь из неё передаваемые настройки.

Наследовать роль может от прототипа по аналогии с js.

```qsp
$role = {
	! $args[0] - идентификатор роли
	! $args[1] - 
	$args['name'] = @em.tag.getNum(@edb.cell.get_value($args[0], 'settings', 'dialogs'), 'name')
	$result = "<font color=#880000><<$args['name']>></font>: %replic-text%"
}
```

Всё равно получается, что роль можно применить только при воспроизведении реплики, либо вставлять ссылку на реплику в один из текстов роли.

Последнее неудобно. Гораздо удобнее писать роли в виде колбэков.

Отсюда следует, что модуль диалогов становится слишком сложным в работе. Нужно хорошо представлять себе работу с ним, чтобы эффективно его использовать, и не факт, что он сильно упростит жизнь авторам.

Нет смысла разрабатывать его по пути упрощения работы с ним. Поэтому имеет смысл делать исключительно под себя, попутно описывая необходимую документацию.
