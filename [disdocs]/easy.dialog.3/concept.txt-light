==Easy Dialog==

Третья версия интерпретатора диалогов. Концептуально сильно отличается от версии 1. Версия 2 так и не была дописана, поэтому нет смысла искать какой-либо промежуточный вариант.

В третьей версии было решено отделить непосредственно генератор диалогов от интерпретатора. Интерпретатор по прежнему реализуется на QSP, в то время как генератор ввиду того, что очень тяжёл и использует множество циклов, выделен в отдельный python-script.

Правила написания исходных текстов для диалогов по сравнению с первой версией не изменились, изменились лишь некоторые настройки, о чём подробно будет написано ниже.

Так же третья версия теперь требует работы с модулем "easy.database", дабы всё в игре было увязано в единую базу данных.

=Структура Таблицы Диалогов=

Таблица Диалогов — это упрощённое название таблицы данных, в которой размещаются некоторые виды объектов, необходимых для реализации диалога.

=Объекты=

--Диалог--

По сути диалог — это корневая реплика без текста. Эта реплика может содержать в себе список необходимых ролей, а так же другие реплики и объекты диалога. Всегда является пассивной репликой.

--Реплики--

Бывают двух типов: пассивные (Questions) и активируемые (Answers). Пассивные реплики как правило отдаются персонажам, с которыми взаимодействует игрок, в то время, как активируемые реплики — являются вариантами выбора, из которых игроку предложено выбирать.

Так же реплики могут обладать различными настройками, например, к ним может быть привязана Роль.

--Роли--

Объект Роль описывает, как выглядит реплика от данного персонажа при выводе на экран. Поскольку мы имеем дело с двумя типами реплик, описывать необходимо оба типа для каждой роли.

=Наследование, каскадность=

По идее нам нужна такая структура диалогов, при которой мы можем не дублировать одни и те же фрагменты диалогов в отдельных диалогах, а подключать их, как отдельные универсальные ветки. При этом реплики в таких ветках должны назначаться ролям, указанным в ссылающихся на них диалогах.

Мы должны иметь возможность создавать роли на базе уже существующих ролей так же, как с каскадным наследованием настроек в первой версии. Однако при этом есть сложность, так как для разных игр структура ролей может различаться.

Как вариант, использовать динамический код, чтобы генерировать обёртку реплики в соответствии с ролью. Например, такой динамический код может получить в качестве аргумента идентификатор роли в таблице данных и извлечь из неё передаваемые настройки.

Наследовать роль может от прототипа по аналогии с js.

```qsp
$role = {
	! $args[0] - идентификатор роли
	! $args[1] - 
	$args['name'] = @em.tag.getNum(@edb.cell.get_value($args[0], 'settings', 'dialogs'), 'name')
	$result = "<font color=#880000><<$args['name']>></font>: %replic-text%"
}
```

Всё равно получается, что роль можно применить только при воспроизведении реплики, либо вставлять ссылку на реплику в один из текстов роли.

Последнее неудобно. Гораздо удобнее писать роли в виде колбэков.

Отсюда следует, что модуль диалогов становится слишком сложным в работе. Нужно хорошо представлять себе работу с ним, чтобы эффективно его использовать, и не факт, что он сильно упростит жизнь авторам.

Нет смысла разрабатывать его по пути упрощения работы с ним. Поэтому имеет смысл делать исключительно под себя, попутно описывая необходимую документацию.

=Написание диалогов=

Для написания диалогов используется специальный синтаксис, который я условно назвал "edsynt". По сути это переработанный синтаксис исходников диалогов для первой версии модуля.

Каждый диалог создаётся в отдельном файле. Генератор перерабатывает все диалоги в единую таблицу данных, с которой вы можете напрямую работать из игры.

"edsynt" предполагает написание диалогов в виде простых деревьев, в которых каждая реплика является узлом, содержащим другие реплики. Воспроизведение одного узла автоматически воспроизводит вложенные в него узлы в виде Пассивных реплик, сразу же отображающихся на экране, или в виде активных реплик, отображающихся в виде гиперссылок (таким образом на активных репликах воспроизведение заканчивается, пока игрок не выберет следующую реплику).

Общий смысл написания диалога раскрыт в разделе [простые диалоги](#простые диалоги).

В третьей версии модуля существенно отличается написание настроек как для отдельных реплик, так и для всего диалога вцелом.

--Корень--

[ВНИМАНИЕ!!! Корень больше не является корневой репликой. Он является отдельной сущностью, олицетворяющей диалог.]

Корень, или Корневая реплика, это Пассивная реплика, с которой начинается интерпретация диалога. Можно сказать, что эта реплика олицетворяет собой весь диалог, поэтому и общие настройки для всего диалога записываются здесь.

Как и для всех прочих реплик, настройки желательно помещать внутрь HTML-комментария. В этом случае, если вы ошибётесь в синтаксисе, настройки всё равно окажутся скрыты от игрока.

Первым делом необходимо перечислить все использующиеся в диалоге роли. Это делается с помощью параметра ''actors'':

```html
<!--

	actors="hero; npc; remark; other; etc;"

-->
```

Идентификаторы ролей следует разделять точкой с запятой, прилегающие пробелы будут проигнорированы.

К идентификаторам ролей предъявляются те же требования, что и к именам переменных в QSP, c дополнительным условием: в них не должны использоваться никакие спецсимволы, включая ''$''.

Следом за параметром ''actors'', в котором перечисляются идентификаторы ролей, необходимо сделать описание каждой роли. Для этого нужно создать специальные описательные блоки, границы которых обозначаются специальными html-тегами.

Название каждого такого тега состоит из слова "actor" и идентификатора роли, поставленного через точку. Примеры:

```html
<!--

	actors="hero; npc; remark;"
	
		<actor.hero></actor.hero>

		<actor.npc></actor.npc>

		<actor.remark></actor.remark>
-->
```

Внутри этих блоков необходимо разместить блоки, содержащие обёртки для реплик.
	* Для активируемых реплик, это блок, ограниченный html-тегами ''<wrap.act></wrap.act>''. Он отвечает за внешний вид кнопок.
	* Для пассивных и активируемых реплик, это блок, ограниченный html-тегами ''<wrap.frase></wrap.frase>''. Он отвечает за внешний вид выводимых на экран фраз.

Эти блоки должны содержать валидный код QSP, который и будет формировать обёртку реплик для указанной роли. Роль может не содержать ни одного из этих блоков, тогда будет использоваться обёртка для реплик, вшитая в интерпретатор.

Как написать собственную обёртку для реплик, описано в разделе [Обёртки](#обёртки).

Помимо обёрток для реплик вы можете использовать для описания каждой роли наборы собственных параметров. Для ролей по-умолчанию определены только значения параметра ''name''. Пример:


```html
<!--

	actors="hero; npc;"
	
		<actor.hero>
			name="%$property['heroname']%"
		</actor.hero>

		<actor.npc>
			name="%$DIALOG_VALUE['current_npc_name']%"
		</actor.npc>
-->
```

Вы можете использовать собственные параметры. Конструкции типа ''%$property['heroname']%'' нужны для извлечения значений из переменных прямо во время формирования обёртки. Вы можете использовать собственные конструкции, ведь обёртки так же можно писать самостоятельно.

В корневой реплике необходимо пометить одну роль как дефолтную для Пассивных реплик, и одну — как дефолтную для Активных реплик. Это делается с помощью вставки тега <default_passive> или <default_active> соответственно.

После перечисления всех ролей, используемых в диалоге, и их описания можно прописать обычные настройки реплик.

Для всего диалога так же можно установить максимальное число реплик на экране.

	* strings:## — максимальное число реплик на экране.

```html
<!--

	actors="hero; npc;"
	
		<actor.hero>name="%$property['heroname']%"</actor.hero>
		<actor.npc>name="%$DIALOG_VALUE['current_npc_name']%"</actor.npc>

	strings:6
-->
```

-Подключение ролей-

При описании роли можно подключить к ней стороннюю роль. При этом в роль копируются все настройки подключаемой роли, кроме маркеров дефолтной роли.

Для подключения используется настройка ''include_role'', размещаемая внутри тегов, описывающих роль.

Пример:

```html
<!--

	actors="hero; npc;"
	
		<actor.hero>
			name="%$property['heroname']%"

			include_role:DIALOG.ROLE
		</actor.hero>
-->
```

Здесь DIALOG — это уникальная метка диалога, а ROLE — это уникальная метка роли в указанном диалоге.

--Отдельные реплики--

Настройки отдельных реплик, влияющие как на воспроизведение каждой отдельной реплики, так и на воспроизведение целых веток реплик.

-Настройки порядка вывода реплик NPC (для веток)-

	* repeat - количество повторов вывода реплик неписи:
		* one - выводится одна реплика. Например, выбранная случайно.
		* once - реплики неписи, кроме одиночных, выводятся единожды. Если реплики исчерпаны, выводится последняя.
		* cicle - реплики выводятся по кругу, т.е. имеют свойство повторяться (это режим по умолчанию).
		* default - если указано данное значение, для количества повторов используется значение, установленное в корне.
	* shuffle - порядок вывода реплик:
		* random - реплики выводятся в случайном порядке.
		* straight - прямой порядок от первой к последней (это режим по умолчанию).
		* default - если указано данное значение, для порядка вывода используется значение, установленное в корне.

[TODO!!! Счёт порядка вывода реплик и количества повторов ведётся только в течении диалога. Как только диалог будет закрыт, счёт обнуляется. Для сохранения счёта реплик, нужно использовать другие способы.]

Пример настроек:

```html
<!--
	repeat:cicle
	shuffle:straight
-->
```

-Настройки отображения (для отдельных реплик)-

	* act_name: :act_name — для активируемой реплики устанавливается указанное название кнопки
	* actor_this — ссылка на роль, применяемую только к этой реплике, и не наследуемую вложенными репликами.

-Настройки отображения (для веток)-

	* act_length:## — устанавливает максимальное число символов от текста активной реплики для формирования названия.
	* actor_act — ссылка на роль, используемую для активируемых реплик.
	* actor_pass — ссылка на роль, используемую для пассивных реплик.

Пример настроек:

```html
<!--
	actor_act:hero
	actor_pass:npc
-->
```

Если указать вместо идентификатора роли слово ''default'', будут использоваться дефолтные роли, определённые в корне.

-Управление репликами-

	* selectact.delete — удаляет на время интерпретации диалога реплику из интерпретации. То есть, если реплика помечена этой меткой и была один раз воспроизведена, она помечается, как скрытая, и больше не воспроизводится, пока на неё не произведут целенаправленный переход.
	* selectact.kill — после воспроизведения реплика удаляется из таблицы диалогов и больше не воспроизводится никогда.
	* <frase_block> </frase_block> — между этими html-тегами заключается сразу серия Пассивных реплик. Каждая строка в таком блоке является отдельной репликой. Чтобы к строке применилась роль, нужно указать эту роль в начале строки с помощью тега <actor:HERO> — вместо HERO можно указать любую нужную роль.
	* <if> </if> — между этими HTML-тегами должно указываться валидное для QSP условие. При выполнении условия реплика воспроизводится. В противном случае реплика остаётся скрытой.
	* <dynamic_code> </dynamic_code> — между этими тегами указывается валидный QSP-код, который будет выполнен при воспроизведении реплики.
	* marker:FIRSTQST — устанавливаем на реплику метку FIRSTQST. Вместо FIRSTQST можно указывать любые непробельные символы. В пределах одного диалога метки не должны повторяться, но между диалогами метки могут повторяться. /* Для меток в таблице диалогов создаются специальные записи, которые могут использоваться для сопоставления меток и реплик. Генератор берёт на себя правильную увязку меток и реплик. Если внутри одного диалога оказываются две одинаковые метки, генератор предупредит вас об этом.*/
	* levelup:## — переход по узлам наверх (назад), на ## узлов вверх.
	* leveljump:MARKER — переход на метку с названием MARKER, то есть принудительное воспроизведение реплики под указанной меткой. Вместо MARKER можно указать любую метку в текущем диалоге.
	* closeup — принудительное закрытие диалога из воспроизводимой реплики. Лучше ставить на активируемую реплику.
	* replic_app:DIALOG.MARKER — подключение реплики из другого диалога к текущему диалогу. Вместо DIALOG указывается уникальный идентификатор диалога, а вместо MARKER указывается название метки в другом диалоге.





