==Руководство пользователя и специфика работы модуля easy.dialog v.2.0.==

=Написание диалогов=

Смотри подготовленное руководство в формате html.

=Добавление диалогов в игру=

Смотри подготовленное руководство в формате html

=Порядок работы модуля=

Модуль условно разделён на две части: генератор и интерпретатор.

--Генератор--

Генератор предназначен для преобразования исходного текста диалога в удобную для воспроизведения форму (таблица данных диалогов). Это преобразование называется генерацией диалога. Диалогом называется набор реплик (начиная от корневой), размещённый в таблице данных диалогов.

-dialog.generate-

Это основная функция для генерации диалога. Порядок вызова:

```qsp
gosub 'dialog.generate',$args[0],$args[1],$args[2]
```

или, если нужно получить таблицу данных диалога на экране в виде готового QSP-кода:

```qsp
*pl $func('dialog.generate',$args[0],$args[1],$args[2])
```

, где

	$args[0] — исходный текст (тело) диалога, написанный по выше изложенным правилам [http://].
	$args[1] — уникальный идентификатор корневой реплики диалога (или просто "ID диалога"). Этот идентификатор впоследствии нужно использовать для вызова диалога.
	$args[2] — управляющая конструкция, которая определяет режим работы генератора:
		get.objs — формируется диалог в виде готового QSP-кода, который достаточно вставить в любом месте игры (простое заполнение массивов);
		get.base — формируется диалог в виде готового QSP-кода, который используется в базе диалогов (заполнение массивов, разбитое на части);
		пустое значение (или не указано) — диалог сразу вносится в таблицу данных диалогов, т.е. сразу в рабочие массивы; таким образом со сгенерированным диалогом сразу можно работать.

Работает функция dialog.generate следующим образом:

	1. Исходный текст, который получила функция, передаётся функции dialog.inTag
	2. Функция dialog.inTag возвращает тот же исходный текст, только вместо тегов типа [: :] и {: :} в возвращённом тексте присутствуют уже пронумерованные по порядку теги типа <answer000000> </answer000000> и <quest0000000> </quest0000000>
	3. Полученный текст, а так же идентификатор корневой реплики, передаются процедуре dialog.tag.inArr, которая вытаскивает реплики из текста и помещает их во временную таблицу данных (набор массивов).
	4. Происходит обращение к процедуре dialog.sets.default с параметром 'generate', которая определяет настройки по-умолчанию для всего диалога.
	5. При обращении к процедуре dialog.sets.transport всем репликам во временной таблице данных сообщаются окончательные настройки.
	6. Происходит обращение к процедуре dialog.replace.ID, где каждой реплике (кроме корневой), присваивается уникальный идентификатор.
	7. С помощью цикла реплики диалога из временной таблицы данных переносятся в рабочую таблицу данных диалогов, либо подготавливается QSP-код, который можно разместить в игре, где и будет производиться заполнение таблицы данных диалогов.
	8. С помощью процедуры dialog.killtemp очищаются временные массивы
	9. Функция возвращает результат, либо (в зависимости от запроса) завершается без возвращения результата.

По ходу работы функции возвращается значение переменной DIALOG_VALUE['base.count'], где ведётся учёт меток, если диалог преобразуется в QSP-код для базы.

Если таблица диалогов до сих пор не была создана в игре, перед началом генерации диалога, функция создаёт пустую реплику. См. также примечание к разделу "Добавление диалогов в игру" [http://].

-dialog.inTag-

Данная функция преобразует исходный текст диалога в тегированный текст, где каждая реплика помещается внутрь пронумерованных xml-тегов типа:
	''<answer000000>'' и ''</answer000000>''
	''<quest0000000>'' и ''</quest0000000>''

Во время работы функции каждой группе из открывающего и закрывающего тега присваивается порядковый номер, таким образом исключается появление одинаковых групп тегов.

Вызов функции:

```qsp
$func('dialog.inTag',$args[0])
```

, где
	$args[0] — исходный текст диалога.

Результатом является переразмеченный исходный текст.

Пример результата работы функции:

npc="
name:Ведущий:name
ncolor:008888
fcolor:008888
"
hero="
name:Вася Пупкин:name
"
Это заголовок диалога. Его корень. Данные реплики будут выведены
на экран как есть, без применения форматирования из настроек диалога.
Тем не менее символы пробелов и табуляций перед строками, а так же
лишние переводы строк будут удалены.
<quest0000022>
	Как вас зовут?
	<answer000009>hero="ncolor:008800"
		Меня зовут Вася.
		<quest0000005>Вас зовут Вася?
			<answer000003>
			npc="fcolor:880000"
			Да, меня зовут Вася.
				<quest0000001>да ну нафиг</quest0000001>
				<answer000002>нет. чистая правда</answer000002>
			</answer000003>
			<answer000004>Нет, никто меня так не зовёт</answer000004>
		</quest0000005>
		<quest0000008>
			Это правда, что вас зовут Васей?
			<answer000006>Правда</answer000006>
			<answer000007>Неправда</answer000007>
		</quest0000008>
	</answer000009>
	<answer000021>hero="ncolor:ff0000"
		Меня зовут Петя.
		<quest0000014>
			Вас зовут Петя?
			<answer000011>Да
				<quest0000010>Как это удобно!</quest0000010>
			</answer000011>
			<answer000013>Нет
				<quest0000012>Вас зовут не Петя? Как неудобно!</quest0000012>
			</answer000013>
		</quest0000014>
		<quest0000017>
			Это правда, что вас зовут Петей?
			<answer000015>Правда</answer000015>
			<answer000016>Неправда</answer000016>
		</quest0000017>
		<quest0000020>Неужели в самом деле Петей Вас зовут?
			<answer000018>В самом деле</answer000018>
			<answer000019>Нет, не в самом</answer000019>
		</quest0000020>
	</answer000021>
</quest0000022>
<!-[count-tag:23]-!>

-dialog.tag.inArr-

Данная функция предназначена для преобразования переразмеченного исходного текста диалога в таблицу данных. При этом создаётся временная таблица данных.

Вызов функции:

gosub 'dialog.tag.inArr',$args[0],$args[1]

, где
	$args[0] — переразмеченный исходный текст диалога
	$args[1] — уникальный идентификатор корневой реплики диалога (или просто "ID диалога")

Результатом работы функции является заполнение необходимыми данными следующих массивов:

	$easy_dialog_base_ID[] — уникальный идентификатор реплики (на данном этапе совпадает с номером группы тегов, из которых реплика была извлечена)
	$easy_dialog_base_PS[] — расположение реплики относительно других реплик (вложенность. Здесь указывается идентификатор реплики, в которую помещена текущая)
	$easy_dialog_base_SC[] — непосредственно тело реплики, включая различные настройки и параметры

Эта функция так же присваивает реплике тип в виде одиночного тега "type-replic:". Указываются значения "answer" — для реплик героя или "quest" — для реплик актёра.

-dialog.replace.ID-

Функция заменяет идентификаторы во временной таблице данных на новые уникальные. При этом из временной базы удаляются пустые реплики, т.е. реплики, не содержащие ни идентификаторов, ни тела, ни настроек, а так же расположенные вне других реплик.

Вызов функции:

gosub 'dialog.replace.ID',$args[0]

, где
	$args[0] — идентификатор корневой реплики диалога

Результатом работы функции является замена значений в массивах:

	$easy_dialog_base_ID[] — уникальный идентификатор реплики (на данном этапе всем репликам, кроме корневой, присваивается идентификатор состоящий из идентификатора корневой реплики диалога, разделительной точки и случайного набора из восьми букв и цифр)
	$easy_dialog_base_PS[] — расположение реплики относительно других реплик.

--Интерпретатор--

Интерпретатор предназначен для воспроизведения диалога, который заранее был сформирован с помощью генератора. Однако он может интерпретировать и исходные тексты диалогов, написанные по вышеизложенным правилам [http://].

-dialog.int-

Функция предназначена для воспроизведения диалога в игре. Режимы работы этой функции подробно описаны в разделе "Добавление диалогов в игру".

Вызов функции:

gosub 'dialog.int',$args[0],$args[1]

, где
	$args[0] — режим работы диалога. Здесь можно передавать идентификатор корневой реплики или исходный текст диалога:
		* если в этом аргументе передаётся идентификатор корневой реплики диалога, запускается воспроизведение уже сгенерированного диалога;
		* если в этом аргументе передаётся не идентификатор корневой реплики, интерпретатор понимает, что к нему пришёл исходный текст диалога, и сначала запускает генератор; таким образом в этом режиме интерпретатор работает точно так же как и в версии модуля 1.0[1].
	$args[1] — здесь передаётся управляющая конструкция. В частности управляющая конструкция, определяющая внешний вид ответных реплик: гиперссылки (answer.href) или действия (answer.act или пустое значение).

Работает функция dialog.int следующим образом:

	1. С помощью функции arrpos производится проверка, присутствует ли в массиве $id_replic[] значение, содержащееся в $args[0]. Если присутствует, то функция запускает воспроизведение диалога (пункт 3).
	2. Если в $id_replic[] нет значения из $args[0], функция понимает, что пришёл исходный текст и запускает генератор dialog.generate[#]. При этом ID корневой реплики диалога создаётся автоматически. После генерации аргументу $args[0] присваивается ID корневой реплики диалога.
	3. Состояние окон сохраняется с помощью функции dialog.screen.save, и все окна очищаются.
	4. Выставляются настройки по умолчанию для диалога с помощью функции dialog.sets.default.
	5. Воспроизводится корневая реплика диалога с помощью функции dialog.replic.int, которой передаётся идентификатор корневой реплики диалога.

-dialog.screen.save-

Процедура определяет содержимое окон до диалога и во время.

Вызов:

gosub 'dialog.screen.save'

Порядок работы:

	1. Сохраняет значения экранов в соответствующие переменные.
	2. Если режим answer.view в позиции answer.href, выбирает из текущего экрана соответствующие блоки, формирует дополнительные, либо генерирует новый экран.

Блоки экранов:

	<avs-dialog_div> ... </avs-dialog_div> — блок, в котором выводятся реплики диалога.
	<avs-head_div> ... </avs-head_div> — блок, в котором выводится заголовок диалога.
	<avs-answer_div> ... </avs-answer_div> — блок, в котором выводятся ответные гиперссылки.

-dialog.replic.int-

Функция воспроизводит указанную реплику.

Вызов функции:

gosub 'dialog.replic.int',$args[0]

, где
	$args[0] — идентификатор (ID, айди) реплики.

Работа функции:

	1. Локальным переменным возвращаются тело реплики, её настройки и тип.
	2. /* Пункт убран. В версии 2.0 не нужен */
	3. С помощью функции dialog.replic.code выполняется динамический код, который заключён в реплике
	4. С помощью функции dialog.replic.print реплика выводится на экран.
	5. С помощью функции dialog.get.daughter получаем список вложенных реплик.
	6. Первым циклом проходит проверка вложенных реплик на соответствие определённым условиям и добавление их в специальные списки. Реплики актёра — в специальную временную микробазу (массивы easy_dialog_temp_var1[] и easy_dialog_temp_var2[]), реплики героя — в переменные args['answerPOS.##'], где ## — порядковые номера.
	7. Второй цикл предназначен для воспроизведения реплик героя, вложенных в текущую. Для воспроизведения используется функция dialog.int.answer
	8. Далее следует сложный алгоритм, определяющий, какая из реплик актёра будет выведена на экран. После определения происходит обращение к функции dialog.int.quest, которая должна воспроизвести реплику актёра.
	9. Если в теле реплики обнаруживается ключевое слово closeup — диалог закрывается.

-dialog.replic.print-

Функция выводит текст реплики на экран.

Вызов функции:

gosub 'dialog.replic.print',$args[0]

, где
	$args[0] — идентификатор реплики.

Порядок работы:

	1. Получаем тип реплики и блок фраз, если реплика содержит блок фраз
	2. Извлекаем настройки дизайна реплик и выводим по ходу.
	3. Выводим блок фраз с указанной задержкой.

Здесь используются такие функции как dialog.replic.addDIV и dialog.replic.get.

-dialog.replic.get-

Функция получает непосредственно текст реплики.

Вызов:

$func('dialog.replic.get',$args[0])

, где
	$args[0] — идентификатор реплики.

Результатом работы функции является чистый текст реплики, т.е. тело реплики, из которого удалены все тексты настроек, коментариев, а также преформатирование.

Изначально в функции присутствовала возможность настроек, но теперь функция работает лишь в одном режиме.

-dialog.replic.prv.if-

Функция проверки выполнения условия.

Вызов:

$func('dialog.replic.prv.if',$args[0])

, где
	$args[0] — идентификатор реплики.

Функция возвращает значение 'true', если в реплике нет условия выведения, либо оно соблюдено, и — 'false', если условие есть и не соблюдено.

-dialog.replic.code-

Функция выполняет динамический код при воспроизведении реплики.

Вызов:

gosub 'dialog.replic.code',$args[0]

, где
	$args[0] — идентификатор реплики.

Результатом работы функции является выполнение динамического кода.

/* добавить возможность использовать в динамическом коде данные из реплики */

-dialog.int.quest-

Функция воспроизводит реплику актёра (вопросную).

Вызов:

gosub 'dialog.int.quest',$args[0]

, где
	$args[0] — идентификатор реплики.

Порядок работы:
	
	1. Счётчик числа обращений к реплике увеличивается на 1 (kolvo_replic[##]+=1)
	2. Происходит обращение к функции интерпретации реплики dialog.replic.int.
	3. C помощью функции dialog.get.jump происходит переход на метку, если она была указана ("levelup:", "leveljump:")

-dialog.int.answer-

Функция воспроизводит ответную реплику (реплику героя) в виде действия или гиперссылки.

Вызов:

gosub "dialog.int.answer",$args[0]

, где
	$args[0] — идентификатор реплики.

Порядок работы:

	1. Получаем исходник реплики, название действия, если указано.
	2. Если название действия получено:
		3. Получаем в виде готового кода список обращений к dialog.replic.int с айди реплик, к которым происходит прыжок. Используется функция dialog.get.jump.
		4. Далее, в зависимости от настроек, получаем действия или гиперссылки с необходимым кодом.

На работу функции влияет режим, выставляемый в переменной $DIALOG_VALUE['answer.view'].

-dialog.closeup-

Процедура закрывает диалог и восстанавливает описание локации и действия.

Вызов:

gosub 'dialog.closeup'

Процедура восстанавливает состояния экранов окна основного описания, окна дополнительного описания и окна действий из переменных. Затем удаляет массив $DIALOG_VALUE[], а так же временные массивы.

-dialog.get.jump-

Функция предназначена для получения списка команд для интерпретации реплик, к которым должно происходить обращение из текущей интерпретируемой.

Вызов:

$func('dialog.get.jump',$args[0])

, где $args[0] — айди текущей интерпретируемой реплики.

Функция перебирает все команды levelup и leveljump, прописанные в текущей реплике, и на их основе генерирует команды типа

gosub 'dialog.replic.int',$args[0]

, где $args[0] — идентификаторы меток, на которые должен осуществиться "прыжок".

-dialog.act.del-

Данная процедура служит для добавления реплики героя в список скрытых с экрана. Реплики будут скрываться до тех пор, пока не произойдёт интерпретация реплики актёра, вложенной в реплику героя. Т.е. пока не произойдёт переход на новую ветку. Даёт зримый эффект в режиме answer.href.

Вызов:

gosub 'dialog.act.del',$args[0]

, где $args[0] — идентификатор реплики, скрываемой с экрана.

Порядок работы:

В переменную $DIALOG_VALUE['list.act.del'] вносятся айди реплик, скрываемых с экрана, при этом каждый айди заключается в квадратные скобки, отбиваются друг от друга переводом строки.

Переменная обнуляется после перехода на новую ветку.

-dialog.replic.del-

Процедура служит для добавления реплики в список скрытых с экрана. Реплики будут скрываться до тех пор, пока диалог не завершится.

Вызов:

gosub 'dialog.replic.del',$args[0]

, где $args[0] — идентификатор реплики, которую требуется больше не интерпретировать.

Порядок работы:

В переменную $DIALOG_VALUE['list.replic.del'] вносятся айди реплик, скрываемых с экрана, при этом каждый айди заключается в квадратные скобки, отбиваются друг от друга переводом строки.

Переменная обнулится при закрытии диалога в момент уничтожения массива $DIALOG_VALUE[].

--Применение настроек--

-dialog.sets.attrib-

Функция заменяет или дополняет набор атрибутов.

Вызов:

$func('dialog.sets.attrib',$args[0],$args[1],$args[2])

, где
	$args[0] — в версии 2.0 не используется.
	$args[1] — на какие атрибуты меняем, новый список.
	$args[2] — старый набор атрибутов.

Порядок работы:

1. Изначально выставляются атрибуты согласно списку старых атрибутов. Специальным циклом из списка вырезаются атрибуты, начиная с последнего. И эти атрибуты применяются в порядке обратном инструкции.
	Например, инструкция была такая: '-b-i-n'. Значит сначала будет применена часть '-n', затем '-i' и только потом '-b'.

2. Затем выставляются атрибуты согласно списку новых атрибутов. Работает тот же цикл по тем же принципам.

Подробнее о назначении и применении атрибутов смотри соответствующий раздел [http://]

-dialog.set.default-

Процедура выставляет настройки по умолчанию, прописывая их в соответствующие ячейки массива $DIALOG_VALUE[].

Вызов:

$func('dialog.set.default',$args[0])

, где $args[0] — указываем, какую настройку хотим получить:
	
	npc.name — Имя актёра (по-умолчанию — нет)
	npc.name.color — Цвет имени актёра (по-умолчанию чёрный 000000)
	npc.name.attrib — Атрибуты имени актёра (по-умолчанию жирный -b)
	npc.frase.color — Цвет фразы актёра (по-умолчанию чёрный 000000)
	npc.frase.attrib — Атрибуты фразы актёра (по-умолчанию обычный -n)
	npc.tire — мыслеотделительный символ фраз актёра (по умолчанию тире)

	hero.name — имя героя (по-умолчанию — нет)
	hero.name.color — цвет имени героя (по-умолчанию серый 888888)
	hero.name.attrib — атрибуты имени героя (по-умолчанию жирный курсив -b-i)
	hero.frase.color — цвет фразы героя (по-умолчанию серый 888888)
	hero.frase.attrib — атрибуты фразы героя (по-умолчанию курсив -i)
	hero.tire — мыслеотделительный символ фраз героя (по умолчанию тире)
	hero.href.color — цвет фразы героя (по-умолчанию серый 008800)
	hero.href.attrib — атрибуты фразы героя (по-умолчанию обычный -n)
	hero.corn — указательный символ начала ссылки (по-умолчанию правая угловая скобка)

	npc.replics.repeat — режим повтора реплик актёра (по-умолчанию по кругу cicle)
	npc.replics.shuffle — режим порядка вывода реплик актёра (по-умолчанию прямой порядок straight)

Порядок работы:

Настройки по-умолчанию извлекаются из корневой реплики. Если в корневой текущая настройка не прописана, она задаётся из значения, прописанного непосредственно в модуле.

Подробнее о настройках по-умолчанию смотри в соответствующем разделе [http://]

-dialog.sets.transport-

Процедура предварительной передачи настроек всей ветке текущего диалога, начиная с корневой реплики.

Вызов:

gosub 'dialog.sets.transport',$args[0],$args[1]

, где $args[0] — уникальный ай-ди корневой реплики, $args[1] — режим работы (если указан 'generate', работает в режиме генерации диалога).

Принцип работы прост.
1. Процедура получает настройки текущей реплики и присваивает эти настройки текущей реплике.
2. Затем перебирает все дочерние реплики текущей, присваивая им настройки текущей.
3. Затем по очереди делает каждую дочернюю реплику от текущей — текущей, и повторяет пункты с 1 по третий. 

Таким образом, если в дочерних репликах прописаны новые настройки, эти настройки перекрывают/заменяют настройки родительской реплики, которые им были переданы.

-dialog.get.sets-

Функция получает набор настроек в виде готовой формы.

Вызов:

$func('dialog.get.sets',$args[0],$args[1])

, где
	$args[0] — айди реплики
	$args[1] — управление (если указан "generate", работает в режиме генерации диалога).

Принцип работы прост. Настройки извлекаются из реплики и, если настройка не прописана, либо требует сброса в default, с помощью функции dialog.sets.default извлекаются настройки по-умолчанию.

--Вспомогательные процедуры--

-dialog.killtemp-

Процедура уничтожает массивы, предназначенные для временных значений.

Вызов:

gosub 'dialog.killtemp'

-dialog.get.daughter-

Функция получает дочерние реплики для данного айди. Результатом работы данного выражения будет 'true' — дочерние найдены, а 'false' — дочерние не найдены.

Вызов:

$func('dialog.get.daughter',$args[0],$args[1],$args[2],$args[3],$args[4])

, где
	$args[0] — айди родительской реплики
	$args[1] — регулярное выражение, по которому производится дополнительная фильтрация
	$args[2] — название массива, в который вносятся айди дочерних объектов для последующего извлечения
	$args[3] — дополнительный фильтр. В данной версии отключен
	$args[4] — режим работы. Если передан 'generate', работает в режиме генерации диалога.

Порядок работы. Циклом перебираются все реплики, расположенные в текущей и если они подходят под фильтр, их айди заносятся в указанный массив.

-----
[1] Если вы собираетесь работать в этом режиме, используйте модуль версии 1.0, поскольку воспроизведение диалогов таким способом в версии 2.0 отнимает в 2-2,5 раза больше времени и заметно подвешивает игру.

=Переменные, отвечающие за состояние диалога=

DIALOG_VALUE['base.count'] — ведёт учёт меток при генерации QSP-кода для базы диалогов.
DIALOG_VALUE['replics.counter'] — хранит номер метки, на которую следует перейти при следующем обращении к базе диалогов.
$DIALOG_VALUE['answer.view'] — хранит настройку внешнего вида реплик героя (ответных реплик):
	answer.href — ответные реплики выводятся в виде гиперссылок
	answer.act или пустое значение — ответные реплики выводятся в виде действий
$DIALOG_VALUE['list.replic.del'] — список реплик, удалённых из диалога на время сеанса.
$DIALOG_VALUE['list.act.del'] — список реплик героя, удалённых после интерпретации. Замена команды delact $selact. Актуально при работе в режиме answer.href
$DIALOG_VALUE['list.act.fix'] — список фиксированных реплик героя (фиксация с реплики снимается после интерпретации, т.е. по нажатию)

$DIALOG_VALUE['screen.main'] — во время работы модуля диалогов хранит исходное содержимое окна основного описания
$DIALOG_VALUE['screen.acts'] — во время работы модуля диалогов хранит исходное содержимое окна действий
$DIALOG_VALUE['screen.stat'] — во время работы модуля диалогов хранит исходное содержимое окна дополнительного описания
DIALOG_VALUE['screen.html'] — во время работы модуля диалогов хранит значение usehtml на момент включения модуля диалогов

$DIALOG_VALUE['screen_now'] — во время работы модуля диалогов здесь хранится весь экран диалога

$DIALOG_VALUE['roof.id'] — идентификатор корневой реплики диалога.