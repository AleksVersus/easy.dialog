<!DOCTYPE html>
<html lang="ru">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link type="text/css" rel="stylesheet" href="../res/css/easy.library.css" />
    <link type="text/css" rel="stylesheet" href="../res/css/offline.window.css" />
    <title>Easy Dialog — Full Manual</title>
</head>
<body>
<div class="em_AROUND">
    <h1>easy.dialog.qsp v 2.0</h1>
    <div class="em_Epigraph">
        <div>
            <p>Модуль разрабатывался для плеера QSP v 5.7.0, тестировался только на нём. Не гарантируется правильная работа на плеерах иных версий. Ошибки и недочёты в модуле устраняются по мере нахождения, поэтому гарантировать безупречную работу даже на "классике" не могу. Тестовая загрузка диалога из ста реплик заняла чуть больше 1000 мс. В режиме [NO PRE-SETS] - около 800 мс. Скорость загрузки диалога зависит от объёма диалога и от глубины вложенности реплик.</p>
            <p>По всем вопросам и предложениям обращаться:</p>
            <ul>
                <li>aleksversus@mail.ru</li>
                <li>lex666endless@gmail.com</li>
                <li>Вконтакте: id40090736</li>
            </ul>
            <p>Изначально модуль создавался для обеспечения нужд игры "Волшебство и сталь".</p>
        </div>
    </div>
    <div class="em_PAGE">
        <p>Подробное руководство по использованию модуля, с примерами.</p>
        <h2>Подключение</h2>

        <p>Предполагается, что вы уже пробовали писать игры на QSP, знаете основные команды и, возможно, знаете, что такое функции, переменные и массивы и как формируется html-форматирование. Впрочем, можно обойтись и без последнего.</p>

        <p>Модуль поставляется в комплекте с библиотекой easy.math.qsp и без неё работать не будет.</p>

        <p>Чтобы подключить модуль к своей игре, нужно:</p>
        <ol>
            <li>Скачать архив и извлечь его содержимое в папку с вашей игрой. В папке с вашей игрой должна появиться папка <span class="emFOLD">lib</span>.
                <ul>
                    <li>После знакомства с примерами файл "<span class="emFOLD">game.easy.dialog.qsp</span>" можно удалить.</li>
                </ul>
            </li>
            <li>Проверить в папке <span class="emFOLD">lib</span> наличие файлов "<span class="emFOLD">easy.dialog.qsp</span>" и "<span class="emFOLD">easy.math.qsp</span>".</li>
            <li>Открыть файл своей игры (например с помощью QGen) и на самой первой локации ввести две строки:
                <p class="em_CODE">
                        <span class="emOPRT">addqst</span> <span class="emTEXT">'lib/easy.dialog.qsp'</span>
                    <br><span class="emOPRT">addqst</span> <span class="emTEXT">'lib/easy.math.qsp'</span>
                </p>
                <p>Если вы пишете игру для Quest Navigator, или плеера версии выше 5.7.0:</p>
                <p class="em_CODE">
                        <span class="emOPRT">inclib</span> <span class="emTEXT">'lib/easy.dialog.qsp'</span>
                    <br><span class="emOPRT">inclib</span> <span class="emTEXT">'lib/easy.math.qsp'</span>
                </p>
            </li>
            <li>Сохранить свою игру.</li>
        </ol>
        <p>Теперь при запуске вашей игры, модуль <span class="emFOLD">"easy.dialog"</span> и библиотека <span class="emFOLD">"easy.math"</span> будут подключаться к игре автоматически.</p>

        <div class="em_Warning">
                Внимание!!! При подключении библиотек к своей игре будьте внимательны. К игре добавляются только те локации, названия которых отсутствуют в вашей игре. Просмотрите список локаций в подключаемых библиотеках, чтобы предупредить совпадения имён.
        </div>
        <h2>Простые диалоги</h2>

        <p>Чтобы использовать модуль, нужно знать, как написать диалог, чтобы модуль вас понял.</p>
        <p>Диалоги пишутся предельно просто и не требуют специальных знаний, кроме тех, которые Вы получите сейчас.</p>
        <p>Диалог - это разговор, как правило, двух персонажей. В игре один персонаж - это герой, которым управляет игрок, другой персонаж - неиграбельный, т.е. игрок условно не может им управлять. Персонаж игрока мы будем называть героем, а персонаж, с которым герой вступает в диалог, просто персонажем, актёром, или неписью (от англ. NPC - non-playable character).</p>
        <p>Фразы, доступные игроку (и соответственно герою), должны выводиться в виде списка действий, доступных для выбора и выполнения. А фразы актёра должны выводиться непосредственно на экран автоматически. Собственно это все различия между одним типом фраз и другим.</p>
        <p>Итак, у нас есть фразы NPC, которые выводятся автоматически, и фразы героя, которые появляются в виде действий и не используются в диалоге, пока игрок не выберет одну из них. Оба типа фраз помещаются между специальными метками. Я называю их тегами.</p>
        <p><span class="emTEXT">{: <span class="emTEXT">Фраза, которую будет произносить неиграбельный персонаж</span> :}</span>   -   фигурная скобка, двоеточие, потом идёт реплика персонажа, потом двоеточие и снова фигурная скобка. "<span class="emTEXT">{:</span>" - открывающий тег. "<span class="emTEXT">:}</span>" - закрывающий тег. Всё, что произносит актёр, помещаем между такими тегами. Каждая отдельная фраза должна помещаться между тегами. Например:</p>

        <p class="em_PF"><span class="emTEXT">   {: Сегодня прекрасная погода. :}
   {: Не думал я, что будет дождь! :}
   {: На город набегают тучи, осенний сплин кого-то мучит... :}</span></p>
        <p><span class="emTEXT">[: <span class="emTEXT">Фраза, которая превратится в действие, а когда игрок выберет действие, станет репликой в диалоге.</span> :]</span>   - квадратная скобка, двоеточие, потом идёт реплика героя, снова двоеточие, квадратная скобка. "<span class="emTEXT">[:</span>" - открывающий тег, "<span class="emTEXT">:]</span>" - закрывающий тег. Всё, что может сказать герой, помещаем между такими тегами. Опять же, каждая отдельная фраза - в отдельных тегах. И каждая такая фраза будет выведена одним действием.</p>
        <p>Фразы героя и актёра можно располагать одна в другой, или несколько в одной. Мало того, можно располагать фразы одного типа друг в друге.</p>
        <p>Зачем это нужно? А вот зачем: диалог собирается и распознаётся по принципу вопрос-ответ. Допустим, реплика актёра - это вопрос, а реплика героя должна быть ответом на вопрос. Но игроку можно предложить несколько вариантов ответов на вопрос. Чтобы написать такой простой диалог: вопрос и несколько ответов, - делаем так:</p>
        <p>Первым делом пишем вопрос. Например, непись должна спросить героя "Как тебя зовут?". Пишем:</p>

        <p class="em_PF"><span class="emTEXT">      {: Как тебя зовут? :}</span></p>
        <p>А теперь ответы на вопрос "вкладываем" в вопрос:</p>

        <p class="em_PF"><span class="emTEXT">      {: Как тебя зовут?
         [:Вася:]
         [:Петя:]
         [:Не твоё дело!:]
         [:Я забыл...:]
      :}</span></p>

        <p>   На экран выведется реплика актёра "Как тебя зовут?" и четыре действия. При щелчке на любом из действий, герой будет произносить фразу, написанную в этих репликах. Например, если игрок выберет действие "Я забыл...", на экран выведется фраза героя "Я забыл...".</p>
        <p>Как сделать так, чтобы по щелчку на действии произносил фразу не только герой, но и актёр? Всё тем же способом. "Вложить" реплику актёра в реплику героя. Разовьём предыдущий пример:</p>

        <p class="em_PF"><span class="emTEXT">   {: Как тебя зовут?
      [:Вася:]
      [:Петя:]
      [:Не твоё дело!:]
      [:А тебя как?
         {:Меня Васькой Пупкиным кличут:}
      :]
   :}</span></p>
        <P>Таким образом, вкладывая реплики друг в друга, вы можете создавать большие ветвистые диалоги. Для примера, вот небольшой ветвистый диалог, на котором отрабатывались первые сборки модуля:</P>

        <p class="em_PF"><span class="emTEXT">   {:
      Как вас зовут?
      [:
         Меня зовут Вася.
         {:Вас зовут Вася?
            [:Да, меня зовут Вася.
               {:да ну нафиг:}
               [:
               нет. чистая правда
               :]
            :]
            [:Нет, никто меня так не зовёт:]
         :}
         {:
            Это правда, что вас зовут Васей?
            [:Правда
            :]
            [:Неправда:]
         :}
      :]
      [:
         Меня зовут Петя.
         {:
            Вас зовут Петя?
            [:Да{:Как это удобно!:}:]
            [:
               Нет
               {:Вас зовут не Петя? Как неудобно!:}
            :]
         :}
         {:
            Это правда, что вас зовут Петей?
            [:Правда:]
            [:Неправда:]
         :}
         {:Неужели в самом деле Петей Вас зовут?
            [:В самом деле:]
            [:Нет, не в самом:]
         :}
      :]
   :}</span></p>
        <P>Обратите внимание на то, как записаны фразы, которые должны выводиться на экран в диалоге. Перед ними есть пустые строки, символы пробелов и табуляций. Модуль сам очистит фразы от мусора и уберёт пустые строки перед фразой и после неё, а так же пробельные символы перед каждой строкой и после неё. То есть даже если вы вставите фразу между тегами вот так:</P>

        <p class="em_PF"><span class="emTEXT">   {:







                     Как вас зовут?






   :}</span></p>
        <P>То на экран всё равно будет выведено: "Как вас зовут?" без пробелов перед репликой и пустых строк.</P>
        <h2>Запуск диалога</h2>
        <P>Теперь, когда Вы знаете, как составлять диалог, нужно освоить его запуск и уяснить некоторые особенности вывода диалога на экран.</P>
        <P>Текст диалога лучше присвоить какой-нибудь переменной. Например:</P>
        <p class="em_PF"><span class="emTEXT"><span class="em_VIOL">$диалог_старушки</span>="{:Добрый вечер, милок.
      [:
         Здравствуйте, бабуся!
      :]
      [:
         Девушка, мы разве знакомы?
      :]
   :}"</span></p>

        <p>Далее делаем вызов диалога командой gosub</p>
        <P><span class="emOPRT">gosub</span> <span class="emTEXT">'dialog.int'</span>,<span class="em_VIOL">$диалог_старушки</span></P>
        <P><span class="emOPRT">gosub</span> - это команда обращения к локации. Плеер обращается к локации "<span class="emTEXT">dialog.int</span>", выполнет на ней весь код и возвращается обратно. После запятой стоит переменная <span class="em_VIOL">$диалог_старушки</span>, в которую, как вы помните, мы поместили диалог. Значение этой переменной будет передано локации "<span class="emTEXT">dialog.int</span>" для обработки.</P>

        <p>При вызове диалога автоматически очистится окно основного описания, окно дополнительного описания и список действий. Когда диалог будет закончен, всё восстановится обратно: и основное и дополнительное описание, и действия даже.</p>
        <p>Данный способ запуска применим в основном для версии модуля 1.0. Способы подключения диалогов к игре для версий модуля 2.0 и выше изложены в <a href="#easy_dialog_ingame">соответствующем разделе</a>.</p>
        <h2>Настройки диалога</h2>
        <h3>Форматирование реплик</h3>

        <p>по умолчанию, все реплики персонажей выводятся чёрным цветом, все реплики героя серым цветом с курсивом. по умолчанию, перед репликами не ставятся имена, но ставится знак тире. Всё это можно изменить и настроить непосредственно в самом тексте диалога.</p>

        <p>Настройки можно вынести за реплики, тогда эти настройки будут считаться настройками по умолчанию. Например:<p>

        <p class="em_PF"><span class="emTEXT">   npc="
   name:Бабуся:name
   "
   hero="name:Солдат Котёнкин:name"

   {:Добрый вечер, милок.
      [:
         Здравствуйте, бабуся!
      :]
      [:
         Девушка, мы разве знакомы?
      :]
   :}</span></p>
        <div class="em_STEP">
            <p>Настройки доступны самые разнообразные.</p>
            <div class="em_STEP">
                <p>
                        <span class="emTEXT">npc="&nbsp;"</span> - настройки отображения фраз неписи в окне основного описания.
                    <br><span class="emTEXT">hero="&nbsp;"</span> - настройки отображения фраз героя в окне основного описания.
                </p>
            </div>
        </div>
        <div class="em_STEP">
            <a id="backprim1"></a>
            <p>Настройки, вкладываемые в <span class="emTEXT">npc="&nbsp;"</span> и <span class="emTEXT">hero="&nbsp;"</span> <a href="#prim1" class="em_PRIM" title="Примечание">[1]</a> :</p>
            <div class="em_STEP">
                <p>
                    <span class="em_BLU">name:&nbsp;:name</span> - имя. Если между двоеточиями нет символов, не отображается.
                    <br><span class="em_BLU">ncolor:</span> - цвет выводимого имени в шестнадцатеричном формате. Если не указан, или указан ошибочно, выводится чёрным (для неписей) или серым (для героя).
                    <br><span class="em_BLU">nattrib:</span> - аттрибуты выводимого имени, указываются подряд без пробелов:
                </p>
                <div class="em_STEP">
                    <span class="em_DBLU">-b</span> - жирный
                    <br><span class="em_DBLU">-i</span> - курсив
                    <br><span class="em_DBLU">-n</span> - нормальный. Сбрасывает значение прочих атрибутов.
                </div>
                <p>по умолчанию, для героя и для неписи выставлен жирный атрибут, для героя - курсив. Аттрибуты считываются в обратном порядке, начиная с последнего, таким образом происходит и применение. Допустим, мы не хотим, чтобы имя героя отображалось курсивом, но продолжало отображаться жирным шрифтом. Пишем "<span class="emTEXT">nattrib:-b-n</span>". Сначала шрифт вернётся к нормальному виду, потом будет применена жирность. Если указать "<span class="emTEXT">nattrib:-n-b</span>", то сначала будет применена жирность, а потом шрифт вернётся к нормальному виду.</p>
                <p>
                    <span class="em_BLU">fcolor:</span> - цвет выводимой фразы в шестнадцатеричном формате. Если не указан, или указан ошибочно, выводится чёрным (для неписей) или серым (для героя).
                    <br><span class="em_BLU">fattrib:</span> - аттрибуты выводимой фразы (см. список выше). Если не указаны, для фраз героя применяется курсив.
                    <br><span class="em_BLU">tire:</span> - вид тире. Можно указать любые непробельные символы, и они будут выводиться перед каждой фразой героя или неписи. Чтобы ничего не выводилось, указывается слово "nope". Чтобы выводились символы пробела, используйте <span class="emTEXT">&amp;nbsp;</span> или поместите тег в круглые скобки "<span class="emTEXT">(tire: )</span>".
                </p>
            </div>
            <a id="replic_sets"></a>
            <p><span class="emTEXT">replics="&nbsp;"</span> - настройки <a href="#replic_sets_a" title="подробнее...">порядка вывода реплик</a>:</p>
            <div class="em_STEP">
                <p><span class="em_BLU">repeat:</span> - количество повторов вывода реплик неписи:</p>
                <div class="em_STEP">
                    <span class="em_DBLU">one</span> - выводится одна реплика. Например, выбранная случайно.
                    <br><span class="em_DBLU">once</span> - реплики неписи, кроме одиночных, выводятся единожды. Если реплики исчерпаны, выводится последняя.
                    <br><span class="em_DBLU">cicle</span> - реплики выводятся по кругу, т.е. имеют свойство повторяться. по умолчанию.
                </div>
                <p><span class="em_BLU">shuffle:</span> - порядок вывода реплик.</p>
                <div class="em_STEP">
                    <p>
                        <span class="em_DBLU">random</span> - случайный порядок
                        <br><span class="em_DBLU">straight</span> - прямой порядок т.е. от первой к последней. по умолчанию.
                    </p>
                </div>
                <p>Счёт порядка вывода реплик и количества повторов ведётся только в течении диалога. Как только диалог будет закрыт, счёт обнуляется. Для сохранения счёта реплик, нужно использовать другие способы.</p>
            </div>
        </div>
        <p>В записи настроек так же не играет роль количество пробельных символов и переводов строк. Единственное что, между настройками должен находиться хотя бы один пробел, символ табуляции, или символ перевода строки. Примеры настроек:</p>

        <p class="em_PF"><span class="emTEXT">   npc="
      name:Бабуся:name
      ncolor:ff8800
      fcolor:886600
      fattrib:-i
      tire:nope
      "
   hero="name:Солдат Котёнкин:name ncolor:000000 fcolor:880088 nattrib:-b-n"
   replics="repeat:one
   shuffle:random"</span></p>
        <p>Непосредственно в тексте реплик можно использовать любые html-теги, поддерживаемые плеером, и таким образом дополнительно форматировать текст. Например, вы можете выделить одно слово в реплике другим цветом:</p>

        <p class="em_PF"><span class="emTEXT">   {:Добрый вечер, милок.
      [:
         Здравствуйте, бабуся!
      :]
      [:
         Девушка, мы разве &lt;font color=#008800&gt;знакомы&lt;/font&gt;?
      :]
   :}</span></p>
        <p>Перед выводом на экран любая реплика облекается в точно такие же html-теги в соответствии с настройками. Например, Вы настроили цвет для фразы:</p>

        <p class="em_PF"><span class="emTEXT">   npc="
      name:Бабуся:name
      fcolor:886600
   "
   {:Добрый вечер, милок.
      [:
         Здравствуйте, бабуся!
      :]
      [:
         Девушка, мы разве &lt;font color=#008800&gt;знакомы&lt;/font&gt;?
      :]
   :}</span></p>
        <P>Перед выводом на экран, будет сформирована строка:</P>

        <p class="em_PF">&lt;font color=#000000&gt;&lt;b&gt;Бабуся:&lt;/b&gt;&lt;/font&gt;&lt;font color=#886600&gt; — Добрый вечер, милок.&lt;/font&gt;</p>

        <p>На экране это будет выглядеть так:</p>

        <p class="em_SCREEN"><span style="color:#000000;font-weight:bold;">Бабуся:</span><span style="color:#886600;"> — Добрый вечер, милок.</span></p>

        <p>Модуль автоматически включает распознавание html-тегов в плеере, при обращении к локации <span class="emTEXT">"dialog.int"</span>.</p>

        <p>Когда игрок выберет действие "Девушка, мы разве <span style="color:#008800;">знакомы</span>?", перед выводом на экран будет сформирована надпись:</p>

        <p class="em_PF">&lt;font color=#888888&gt;&lt;i&gt; — Девушка, мы разве &lt;font color=#008800&gt;знакомы&lt;/font&gt;?&lt;/i&gt;&lt;/font&gt;</p>

        <p>На экране это будет выглядеть так:</p>

        <p class="em_SCREEN"><span style="font-style: italic;color:#888888;"> — Девушка, мы разве <span style="color:#008800;">знакомы</span>?</span></p>

        <p>То есть будет сохранено автоматическое форматирование и форматирование, которое вы пропишете прямо внутри фразы. Это очень удобно, если нужно форматировать только одну реплику, предложение в реплике, или слово. Html-теги можно использовать и при указании имени, тогда имя будет отличаться от основного цвета.</p>

        <h3>Наследование настроек</h3>

        <p>Указывать настройки можно не только для всего диалога вцелом, но и для отдельных реплик и даже для целых веток. Возьмём наш старый пример и немного его модифицируем:</p>

        <p class="em_PF"><span class="emTEXT">   npc="
   name:Ведущий:name
   ncolor:008888
   fcolor:008888
   "
   hero="
   name:Вася Пупкин:name
   "

   {:
      Как вас зовут?
      [:

      hero="ncolor:008800"
         Меня зовут Вася.
         {:Вас зовут Вася?
            [:
            npc="fcolor:880000"
            Да, меня зовут Вася.
               {:да ну нафиг:}
               [:
               нет. чистая правда
               :]
            :]
            [:Нет, никто меня так не зовёт:]
         :}
         {:
            Это правда, что вас зовут Васей?
            [:Правда
            :]
            [:Неправда:]
         :}
      :]
      [:
      hero="ncolor:ff0000"
         Меня зовут Петя.
         {:
            Вас зовут Петя?
            [:Да{:Как это удобно!:}:]
            [:
               Нет
               {:Вас зовут не Петя? Как неудобно!:}
            :]
         :}
         {:
            Это правда, что вас зовут Петей?
            [:Правда:]
            [:Неправда:]
         :}
         {:Неужели в самом деле Петей Вас зовут?
            [:В самом деле:]
            [:Нет, не в самом:]
         :}
      :]
   :}</span></p>
        <p>До начала диалога мы прописали настройки, которые будут считаться настройками по умолчанию. Первым делом на экран будет выведена фраза "Как вас зовут?" с настройками для npc, которые указаны для всего диалога. Для всего диалога указано так же и имя героя, но не указан ни цвет, ни аттрибуты жирности/наклона, поэтому будут применяться настройки по умолчанию. То есть цвет имени героя будет серым. Однако, как только игрок выберет одно из выпавших действий:</p>

        <p class="em_ACTBTN">Меня зовут Вася</p>

        <p>или</p>

        <p class="em_ACTBTN">Меня зовут Петя</p>

        <p>будут применены настройки, вложенные в это действие. Эти настройки подменят собой настройки, указанные для всего диалога, но лишь те из них, которые указаны явно. Так, если игрок выберет действие "Меня зовут Вася", имя героя для текущей и всех вложенных реплик будет зелёным. Все остальные настройки останутся прежними. Смотрим дальше. После выбора действия "Меня зовут Вася", актёр "переспросит": "Вас зовут Вася?", фраза эта появится на экране всё с теми же общими настройками для всего диалога. Однако вслед за ней на экране появятся два действия:</p>

        <p class="em_ACTBTN">Да, меня зовут Вася.</p>

        <p> и </p>

        <p class="em_ACTBTN">Нет, никто меня так не зовёт</p>

        <p>При выборе первого, настройка цвета для вывода фраз неписи изменится, и следующая фраза "да ну нафиг" появится на экране, раскрашенная красным цветом. Таким образом, как уже было сказано, для ветки реплик, или реплики, изменяется только та настройка, которая была явно указана. Не указанные настройки достаются в наследство от старшей реплики (т.е. той, в которую мы вложили текущую).</p>

        <h3>Сброс настроек</h3>

        <p>Для сброса настроек в значение, предопределённое для всего диалога (значения по умолчанию), используется ключевое слово default.</p>
        <div class="em_STEP">
            <p>
                    <span class="emTEXT">npc="default"</span>   - сбрасывает все настройки реплик неписи в значения по умолчанию (дефолтные значения),
                <br><span class="emTEXT">hero="default"</span>   - сбрасывает все настройки реплик героя в дефолтные значения,
                <br><span class="emTEXT">replics="default"</span> - сбрасывает все настройки порядка вывода реплик в дефолтные значения.
            </p>
        </div>
        <p>Можно сбрасывать так же и отдельную настройку, указав слово <span class="emTEXT">default</span> после двоеточия. Например, сбросить цвет фраз:</p>

        <p><span class="emTEXT">fcolor:default</span></p>
        <a id="replic_sets_a"></a>

        <h3>Порядок вывода реплик</h3>

        <p><a href="#replic_sets">Выше</a> уже были обозначены основные настройки порядка вывода реплик. Рассмотрим подробнее их поведение на примере последнего диалога, а точнее вот этой его части:</p>

        <p class="em_PF"><span class="emTEXT">  [:
  hero="ncolor:ff0000"
     Меня зовут Петя.
     <span class="emVAR">{:
        Вас зовут Петя?
        [:Да{:Как это удобно!:}:]
        [:
           Нет
           {:Вас зовут не Петя? Как неудобно!:}
        :]
     :}</span>
     <span class="em_VIOL">{:
        Это правда, что вас зовут Петей?
        [:Правда:]
        [:Неправда:]
     :}</span>
     <span class="em_DBLU">{:Неужели в самом деле Петей Вас зовут?
        [:В самом деле:]
        [:Нет, не в самом:]
     :}</span>
  :]</span></p>
        <p>Для наглядности разные реплики выделены разными цветами.</p>
        <p>Предположим игрок выбрал действие "Меня зовут Петя". Какая из трёх реплик неписи должна быть выведена? Вот за это и отвечают настройки порядка вывода реплик.</p>
        <div class="em_STEP">
            <p><span class="emTEXT">shuffle:</span>   - настройка, определяющая выбор следующей реплики. Можно указать один из вариантов:</p>
            <div class="em_STEP">
                <p>
                        <span class="em_BLU">random</span>   - реплика неписи будет выбрана случайным образом.
                    <br><span class="em_BLU">straight</span>   - будет выбрана следующая реплика в порядке очереди. Т.е. если это первый выбор действия "Меня зовут Петя", будет выведена первая реплика (отмечена красным цветом), если игрок второй раз нажмёт на действие, будет выведена вторая реплика (отмечена фиолетовым цветом), и т.д.
                </p>
            </div>
            <p><span class="emTEXT">repeat:</span>   - настройка, определяющая режим повтора реплик. Можно указать один из вариантов:</p>
            <div class="em_STEP">
                <p>
                        <span class="em_BLU">one</span>   - всякий раз при выборе этого действия будет выводиться одна и та же реплика. Например, была выставлена настройка <span class="emTEXT">shuffle:random</span>. Когда игрок выберет действие "Меня зовут Петя", случайным образом будет выбрана одна из реплик, и показана на экране. В следующий раз, когда игрок вновь выберет это же действие, вновь на экран будет выведена та же самая реплика.
                    <br><span class="em_BLU">once</span>   - реплики будут выводиться не повторяясь по одному разу. После вывода последней реплики всё время будет выводиться только она. Например, была выставлена настройка <span class="emTEXT">shuffle:straight</span>. Когда игрок выберет действие "Меня зовут Петя" первый раз, на экран будет выведена первая реплика (выделена красным цветом. Во второй раз появится вторая реплика (выделена фиолетовым), в третий раз - третья (синяя. Последняя реплика). В четвёртый, пятый и далее будет выводиться третья реплика.
                    <br><span class="em_BLU">cicle</span>   - реплики будут выводиться непрерывно по кругу. Если выставлена настройка <span class="emTEXT">shuffle:straight</span>, первый раз выведется первая реплика, второй раз - вторая, третий - третья, на четвёртый раз - вновь первая, потом снова: вторая, третья, первая, вторая... и т.д. Для настройки <span class="emTEXT">shuffle:random</span> выбор реплики несколько сложнее. Первый раз, когда игрок выберет действия, реплика определится случайным образом из трёх. На второй раз случайным образом выбирается одна из двух оставшихся реплик. Потом последняя оставшаяся. В четвёртый раз вновь происходит выбор случайным образом из трёх реплик, и т.д.
                </p>
            </div>
        </div>

        <h2>Чуть более сложные диалоги</h2>

        <h3>Корни, ветви и узлы</h3>
        <p>Для продолжения нам нужно разобраться в структуре диалогов и договориться о терминологии.</p>
        <p>Из предыдущего раздела мы узнали, как пишутся диалоги. Реплики персонажа помещаются между тегами "{:" и ":}", а реплики героя между "[:" и ":]". При этом реплики персонажа должны выводиться на экран автоматически, а реплики героя сначала представать в виде действий. Чтобы соотнести одни реплики с другими, мы научились "вкладывать" одни реплики в другие. Выбор одной из реплик приводит к выводу вложенных реплик, те в свою очередь тянут за собой ещё вложенные реплики и т.д.</p><p>Но с чего же модуль начинает? Должна же быть какая-то реплика, с которой начинается вывод всех остальных реплик. Да. Такая реплика есть, хотя до сих пор мы не называли её репликой и не использовали как реплику. Это реплика, которая не включается в теги и собственно вынесена из диалога. В ней прописываются все дефолтные настройки. Она называется корнем диалога, корневой репликой или заголовком диалога. Модуль не применяет к ней никаких настроек форматирования и все прописанные в ней фразы выводятся как есть, без имени персонажа или героя перед ними. Возьмём предпоследний пример и слегка его изменим, чтобы взглянуть на то, как выглядит корень диалога (подсвечен фиолетовым цветом):</p>

        <p class="em_PF"><span class="emTEXT">   <span class="em_VIOL">npc="
   name:Ведущий:name
   ncolor:008888
   fcolor:008888
   "
   hero="
   name:Вася Пупкин:name
   "
   Это заголовок диалога. Его корень. Данные реплики будут выведены
   на экран как есть, без применения форматирования из настроек диалога.
   Тем не менее символы пробелов и табуляций перед строками, а так же
   лишние переводы строк будут удалены.</span>
   {:
      Как вас зовут?
      [:

      hero="ncolor:008800"
         Меня зовут Вася.
         {:Вас зовут Вася?
            [:
            npc="fcolor:880000"
            Да, меня зовут Вася.
               {:да ну нафиг:}
               [:
               нет. чистая правда
               :]
            :]
            [:Нет, никто меня так не зовёт:]
         :}
         {:
            Это правда, что вас зовут Васей?
            [:Правда
            :]
            [:Неправда:]
         :}
      :]
      [:
      hero="ncolor:ff0000"
         Меня зовут Петя.
         {:
            Вас зовут Петя?
            [:Да{:Как это удобно!:}:]
            [:
               Нет
               {:Вас зовут не Петя? Как неудобно!:}
            :]
         :}
         {:
            Это правда, что вас зовут Петей?
            [:Правда:]
            [:Неправда:]
         :}
         {:Неужели в самом деле Петей Вас зовут?
            [:В самом деле:]
            [:Нет, не в самом:]
         :}
      :]
   :}
</span></p>
        <p>Итак, корень - это реплика, которая помещена вне остального диалога, вне тегов, но меж тем в неё "помещены" все остальные реплики. Корень - это реплика, с которой начинается вывод диалога на экран. Естественно, если текст реплики отсутствует, на экран ничего не выводится, даже пустые строки.</p>
        <p>Когда модуль находит первую реплику диалога (его корень) и выводит её на экран (или не выводит, если фраза не прописана), он находит также и все вложенные реплики. В нашем примере он отыщет всего одну реплику "Как вас зовут?". Для наглядности я выделил её красным:</p>

        <p class="em_PF"><span class="emTEXT">   <span class="em_VIOL">npc="
   name:Ведущий:name
   ncolor:008888
   fcolor:008888
   "
   hero="
   name:Вася Пупкин:name
   "
   Это заголовок диалога. Его корень. Данные реплики будут выведены
   на экран как есть, без применения форматирования из настроек диалога.
   Тем не менее символы пробелов и табуляций перед строками, а так же
   лишние переводы строк будут удалены.</span>
   <span class="em_RED">{:
      Как вас зовут?</span>
      [:

      hero="ncolor:008800"
         Меня зовут Вася.
         {:Вас зовут Вася?
            [:
            npc="fcolor:880000"
            Да, меня зовут Вася.
               {:да ну нафиг:}
               [:
               нет. чистая правда
               :]
            :]
            [:Нет, никто меня так не зовёт:]
         :}
         {:
            Это правда, что вас зовут Васей?
            [:Правда
            :]
            [:Неправда:]
         :}
      :]
      [:
      hero="ncolor:ff0000"
         Меня зовут Петя.
         {:
            Вас зовут Петя?
            [:Да{:Как это удобно!:}:]
            [:
               Нет
               {:Вас зовут не Петя? Как неудобно!:}
            :]
         :}
         {:
            Это правда, что вас зовут Петей?
            [:Правда:]
            [:Неправда:]
         :}
         {:Неужели в самом деле Петей Вас зовут?
            [:В самом деле:]
            [:Нет, не в самом:]
         :}
      :]
   <span class="em_RED">:}</span>
</span></p>
        <p>Распознав тип этой реплики, модуль поймёт, что она должна быть выведена автоматически и повторит ту же процедуру, что проделал с корневой репликой, но на этот раз применит к ней настройки. Т.е. выведет фразу как реплику неписи. Затем он вновь проверит, нет ли в этой реплике вложенных и обнаружит целых две. Каждую из них я выделил отдельным цветом:</p>

        <p class="em_PF"><span class="em_VIOL">   npc="
   name:Ведущий:name
   ncolor:008888
   fcolor:008888
   "
   hero="
   name:Вася Пупкин:name
   "
   Это заголовок диалога. Его корень. Данные реплики будут выведены
   на экран как есть, без применения форматирования из настроек диалога.
   Тем не менее символы пробелов и табуляций перед строками, а так же
   лишние переводы строк будут удалены.</span>
   <span class="em_RED">{:
      Как вас зовут?
      <span class="em_BLU">[:hero="ncolor:008800"
         Меня зовут Вася.
         <span class="emTEXT">{:Вас зовут Вася?
            [:
            npc="fcolor:880000"
            Да, меня зовут Вася.
               <span class="em_BLCK">{:да ну нафиг:}
               [:нет. чистая правда:]</span>
            :]
            <span class="em_BLCK">[:Нет, никто меня так не зовёт:]</span>
         :}</span>
         <span class="emTEXT">{:
            Это правда, что вас зовут Васей?
            <span class="em_BLCK">[:Правда
            :]
            [:Неправда:]</span>
         :}</span>
      :]</span>
      <span class="emFUNC">[:hero="ncolor:ff0000"
         Меня зовут Петя.
         <span class="emTEXT">{:
            Вас зовут Петя?
            [:Да<span class="em_BLCK">{:Как это удобно!:}</span>:]
            [:Нет
               <span class="em_BLCK">{:Вас зовут не Петя? Как неудобно!:}</span>
            :]
         :}</span>
         <span class="emTEXT">{:
            Это правда, что вас зовут Петей?
            <span class="em_BLCK">[:Правда:]</span>
            <span class="em_BLCK">[:Неправда:]</span>
         :}
         {:Неужели в самом деле Петей Вас зовут?
            <span class="em_BLCK">[:В самом деле:]</span>
            <span class="em_BLCK">[:Нет, не в самом:]</span>
         :}</span>
      :]</span>
   :}</span></p>
        <p>Каждая из этих реплик появится в виде действия. Искать вложенные в них реплики не имеет смысла, пока игрок не выберет одно из действий, поэтому модуль пока остановится.</p>
        <p>Мы тоже остановимся, но совсем по другой причине. На этом примере мы увидели сразу два элемента диалога: узел и ветви. Узлом считается любая реплика, в которую "вложены" другие реплики. Не обязательно две. Может быть и одна, и три, и сто тысяч миллионов. Узлы различаются по типам точно так же, как и реплики: узел с репликой персонажа (актёрский узел) и узел с репликой героя (геройский узел, узел действия). Реплика, в которую не "вложено" ни одной другой реплики, называется финальной (последней, конечной. В нашем примере финальные реплики выделены чёрным цветом.). Две однотипные реплики, вложенные в одну реплику, считаются (и называются) ветвями диалога. Такие реплики называются одноуровневыми, то есть находящимися на одном уровне. Уровень реплики считается по количеству узлов, которые ей предшествовали. Поскольку корневой реплике не предшествует ни одного узла, она считается нулевым уровнем. Реплика "Как вас зовут?" из примера - первый уровень, и т.д.</p>
        <a id="head-hide-replics"></a><h3>Скрытый узел</h3>
        <p>Иногда нужно скрыть узел или целую ветку, чтобы она не выводилась ни при каких условиях, пока не будет осуществлён <a href="#prinuditelny_perehod" title="заголовок: Принудительные переходы и закрытие диалога">принудительный переход</a>. Чтобы сделать это нужно завести пустой узел действия. Особенность работы модуля состоит в том, что он не выводит действия с пустым именем, поэтому в пустых узлах действий можно прятать другие реплики и целые ветви. Пример:</p>

        <p class="em_PF"><span class="emTEXT">   [:
      {: Скрытая реплика :}
      {: Ещё одна скрытая реплика :}
      {: А это целая скрытая ветка
         [:
            Да, а вот и ответвление
            {:И финальная реплика:}
         :]
         [:
            Да, а вот и другое ответвление
            {:И ещё одна финальная:}
         :]
      :}
   :]</span></p>
        <h3>Ремарки</h3>

        <p>Ремарка - это авторский текст, который бывает нужно поместить между репликами. Специальных настроек для ремарок нет, но делать их, тем не менее, просто. Для этого в текущую реплику неписи или героя можно добавить реплику с настройками, отменяющими имя актёра и тире (код ремарки выделен голубым цветом):</p>

        <p class="em_PF"><span class="emTEXT">   {:
      npc="name:Ведущий:name"
      Как вас зовут?
      <span class="em_BLU">{:
         npc="name::name
         tire:nope"
         &lt;i&gt;
         Что Вы на это ответите?
         &lt;/i&gt;
      :}</span>
   :}</span></p>
        <p>Ремарки желательно делать финальными репликами, хотя и не обязательно.</p>
        <h4>Ремарки внутри реплики</h4>
        <p>Ремарки внутри реплики - это некоторые авторские пояснения, которые нужно вывести непосредственно внутри реплики. Например, прервать речь актёра, чтобы пояснить, какое действие он выполняет, пока произносит фразу. Или указать с какой интонацией или силой произносится фраза. Вот примеры таких ремарок:</p>
        <div class="em_SCREEN">
            <p><span style="color:#008888;font-weight:bold;">Мишель <span style="color:#888888;font-style:italic;font-weight:normal;">(громко)</span>:</span><span style="color:#000000;"> — Яичница с ветчиной, это сколько?</span></p>
            <p><span style="color:#008800;font-weight:bold;">Мыса:</span> <span style="color:#000000;">— На весну оставляю, <span style="color:#888888;font-style:italic;font-weight:normal;">— хныча, малец потёр багровое ухо. —</span> Голодно будет.</span></p>
        </div>
        <p>В первом случае ремарка идёт сразу после имени и её отличие от имени в том, что она написана нежирным шрифтом, курсивом и серым цветом. Во втором случае ремарка прерывает прямую речь, и в отличие от прямой речи она написана курсивом и другим цветом. Последнюю сделать проще всего. Мы просто вставляем в фразу html-теги, которые изменят цвет и наклон текста:</p>

        <p class="em_PF"><span class="emTEXT">   {:
      npc="name:Мыса:name ncolor:008800 fcolor:000000 nattrib:-b-n fattrib:-n"
      На весну оставляю, &lt;i&gt;&lt;font color="888888"&gt;— хныча, малец потёр багровое ухо. —&lt;/font&gt;&lt;/i&gt; Голодно будет.
   :}</span></p>
        <p>Чтобы сделать ремарку для первого случая, можно прибегнуть к одной из хитростей. Например, можно задать персонажу пустое имя и полностью прописать строку реплики со всеми именами, тегами и пр.:</p>

        <p class="em_PF"><span class="emTEXT">   {:
      npc="name:Мишель:name ncolor:008800 fcolor:000000 nattrib:-b-n fattrib:-n"
      {:npc="name::name"
      &lt;font color="008888"&gt;&lt;b&gt;Мишель &lt;/b&gt;&lt;i&gt;&lt;font color="888888"&gt;(громко)&lt;/font&gt;&lt;/i&gt;&lt;b&gt;:&lt;/b&gt;&lt;/font&gt;
      &lt;font color="000000"&gt; — Яичница с ветчиной, это сколько?&lt;/font&gt;
      :}
   :}</span></p>
        <p>Или изменить имя персонажа на имя, в которое уже будет включена ремарка:</p>

        <p class="em_PF"><span class="emTEXT">   {:
      npc="name:Мишель:name ncolor:008800 fcolor:000000 nattrib:-b-n fattrib:-n"
      {:npc="name:Мишель &lt;/b&gt;&lt;i&gt;&lt;font color="888888"&gt;(громко)&lt;/font&gt;&lt;/i&gt;&lt;b&gt;:name"
      — Яичница с ветчиной, это сколько?
      :}
   :}</span></p>
        <p>В последнем случае писанины меньше, однако нужно очень хорошо представлять себе, какие настройки применяются к имени.

            <a id="head-kak_izbezhat_o4istki_spiska_deystviy"></a><h3>Как избежать очистки списка действий</h3>

        <p>Особенность поведения модуля такова, что если узлом была реплика актёра, а ветвями являются реплики героя, производится очистка списка действий и вывод новых. Чтобы вывести новое действие при щелчке на одном из действий списка, но не удалять старые, помещать реплику героя следует непосредственно в предыдущую реплику героя. Так сделано в предпоследнем примере в реплике "Да, меня зовут Вася.":</p>

        <p class="em_PF"><span class="emTEXT">   [:   npc="fcolor:880000"
      Да, меня зовут Вася.

      {:да ну нафиг:}
      [:нет. чистая правда:]
   :]</span></p>

        <h4>Удаление действия из списка</h4>

        <p>Иногда необходимо не добавлять действия, не удаляя прочие, а удалить одно действие из списка не обновляя список. Для этого была введена команда <span class="emTEXT">selectact.delete</span>. Прописывать её можно только для реплик героя. </p>

        <h3>Блок последовательных реплик</h3>
        <p>Иногда нужно вывести сразу не одну, не две, а несколько реплик поочерёдно от героя и персонажа</p><p>Для примера возьмём вот такой отрывок:</p>
        <div class="em_SCREEN">
            <p><span style="font-weight: bold;color:#008888;">Мишель <span style="font-weight:normal;">(громко)</span>:</span> <span style="color:#000000;">Яичница с ветчиной, это сколько?</span> </p>
            <p><span style="font-weight: bold;color:#888888;">Женский голос <span style="font-weight:normal;">(громко)</span>:</span> <span style="color:#000000;">Сто восемьдесят.</span></p>
            <p><span style="font-style: italic;">Мишель поворачивается лицом к стойке.</span></p>
            <p><span style="font-weight: bold;color:#008888;">Мишель:</span> <span style="color:#000000;">Ладно. Делайте.</span></p>
            <p><span style="font-weight: bold;color:#888888;">Женщина:</span> <span style="color:#000000;">Хорошо.</span></p>
        </div>
        <p>У нас два собеседника: Женщина и Мишель. Пусть неписью побудет Мишель, а героем - Женщина.</p><p>Как обычно, для реплики мы задаём настройки:</p>

        <p class="em_PF"><span class="emTEXT">   npc="name:Мишель:name ncolor:008888 nattrib:-b-n fcolor:000000 fattrib:-n tire:nope"
   hero="name:Женщина:name ncolor:888888 nattrib:-b-n fcolor:000000 fattrib:-n tire:nope"</span></p>
        <p>Если бы мы использовали только возможность вкладывать одну реплику в другую, мы могли бы написать этот диалог так:</p>

        <p class="em_PF"><span class="emTEXT">   npc="name:Мишель:name ncolor:008888 nattrib:-b-n fcolor:000000 fattrib:-n tire:nope"
   hero="name:Женщина:name ncolor:888888 nattrib:-b-n fcolor:000000 fattrib:-n tire:nope"
   {:npc="name::name"
   &lt;font color="008888"&gt;&lt;b&gt;Мишель&lt;/b&gt; (громко)&lt;b&gt;:&lt;/b&gt;&lt;/font&gt; &lt;font color="000000"&gt;Яичница с ветчиной, это сколько?&lt;/font&gt;
      {:
      &lt;font color="888888"&gt;&lt;b&gt;Женский голос&lt;/b&gt; (громко)&lt;b&gt;:&lt;/b&gt;&lt;/font&gt; &lt;font color="000000"&gt;Сто восемьдесят.&lt;/font&gt;
         {:
         &lt;i&gt;Мишель поворачивается лицом к стойке.&lt;/i&gt;
            {:npc="name:Мишель:name"
               Ладно. Делайте.
               {:npc="name:Женщина:name ncolor:888888 fcolor:000000"
                  Хорошо.
               :}
            :}
         :}
      :}
   :}</span></p>
        <p>Но это не только громоздко, но ещё и неудобно, и даёт дополнительную нагрузку на плеер. Специально для таких случаев была придумана конструкция блоков реплик (блок фраз). Делается она очень просто. Между тегами <span class="emTEXT">frase-block: :frase-block</span> помещаются строки нашего диалога. Каждая строка считается отдельной фразой/репликой. Если в начале строки вписать <span class="emTEXT">&lt;npc-name&gt;</span>, то к строке будет применено форматирование согласно настройкам неписи. Если в начале строки указать  <span class="emTEXT">&lt;hero-name&gt;</span>, то к ней будет применено форматирование согласно настройками героя. Если ни той ни другой метки в строке не обнаружено, дополнительное форматирование к строке не применяется. Таким образом наш диалог можно записать в одну "реплику":</p>

        <p class="em_PF"><span class="emTEXT">   npc="name:Мишель:name ncolor:008888 nattrib:-b-n fcolor:000000 fattrib:-n tire:nope"
   hero="name:Женщина:name ncolor:888888 nattrib:-b-n fcolor:000000 fattrib:-n tire:nope"
   {:
      frase-block:
         &lt;font color="008888"&gt;&lt;b&gt;Мишель&lt;/b&gt; (громко)&lt;b&gt;:&lt;/b&gt;&lt;/font&gt; &lt;font color="000000"&gt;Яичница с ветчиной, это сколько?&lt;/font&gt;
         &lt;font color="888888"&gt;&lt;b&gt;Женский голос&lt;/b&gt; (громко)&lt;b&gt;:&lt;/b&gt;&lt;/font&gt; &lt;font color="000000"&gt;Сто восемьдесят.&lt;/font&gt;
         &lt;i&gt;Мишель поворачивается лицом к стойке.&lt;/i&gt;
         &lt;npc-name&gt;Ладно. Делайте.
         &lt;hero-name&gt;Хорошо.
      :frase-block
   :}</span></p>
        <p>Фразы, указанные в блоке, будут выводиться одна за другой с небольшой задержкой. Блок фраз имеет приоритет перед простым текстом реплики.</p>
        <h3>Реплики по условию</h3>
        <p>Иногда нам необходимо намеренно скрыть реплику до тех пор, пока не будет выполнено определённое условие. Например, реплика должна появляться только в тех случаях, когда в рюкзаке героя есть "Странный синий камушек", а до той поры быть скрыта. Чтобы написать такую скрытую реплику, используем специальные теги <span class="emTEXT">iffing:&nbsp;:iffing</span>. Если Вы не первый день пользуетесь QSP, Вы знаете, что такое оператор условия и уже видели конструкции типа:</p>
        <p class="em_PF"><span class="emTEXT">   <span class="em_DBLU">if <span class="emFUNC">obj</span><span class="emOPRT">(<span class="emTEXT">'Странный синий камушек'</span>)</span>:</span>
      <span class="emCOMM">! ---- какой-то код .... ---------</span>
   <span class="em_DBLU">end</span></span></p>
        <p>Так вот. Между тегами <span class="emTEXT">iffing:&nbsp;:iffing</span> нужно поместить всё, что находилось бы в этой конструкции между "<span class="em_DBLU">if</span>" и "<span class="em_DBLU">:</span>". То есть реплика по условию выглядела бы так:</p>

        <p class="em_PF"><span class="emTEXT">  {:
      iffing:<span class="emFUNC">obj</span><span class="emOPRT">(<span class="emTEXT">'Странный синий камушек'</span>)</span>:iffing
      О, я вижу ты нашёл странный синий камушек!
   :}</span></p>
        <P>Или так:</P>

        <p class="em_PF"><span class="emTEXT">   [:
      iffing:<span class="emFUNC">obj</span><span class="emOPRT">(<span class="emTEXT">'Странный синий камушек'</span>)</span>:iffing
      Не знаешь, что это за странный синий камушек?
   :]</span></p>
        <p>Используя подобную возможность, следует помнить, что все реплики, "вложенные" в реплику, выводимую по условию, окажутся недоступны до выполнения условия.</p>
        <h3>Выполнение кода при выводе реплики</h3>
        <p>Иногда при выводе реплики нужно выполнить какой-нибудь код. Особенно часто это бывает необходимо при выборе действия (выводится реплика героя). На такой случай предусмотрены специальные теги <span class="emTEXT">dynamic-code:&nbsp;:dynamic-code</span>. Между ними можно разместить любой код QSP, который будет выполнен только при выводе реплики на экран. Если текст реплики не задан, на экран, конечно, ничего не выведется, но код всё равно будет выполнен. Код выполняется непосредственно перед выводом реплики на экран, поэтому если Вы пропишете вывод строки из кода, строка появится на экране до выводимой реплики. Вот пример вывода ремарки до реплики, используя код в реплике.</p>

        <p class="em_PF"><span class="emTEXT">   {:
      dynamic-code:
      *pl '&lt;i&gt;&lt;font color="888888"&gt;Мишель поворачивается лицом к стойке.&lt;/font&gt;&lt;/i&gt;'
      :dynamic-code:
      Ладно. Делайте.
   :}</span></p>
        <a id="prinuditelny_perehod"></a><h3>Принудительные переходы по репликам. Закрытие диалога</h3>
        <p>Принудительные переходы по репликам можно вставлять на любой реплике. Такие переходы не зависят от выполнения условий вывода реплики, можно перейти даже на <a href="#head-hide-replics" title="заголовок: Скрытый узел">скрытые реплики</a>. Однако не рекомендуется злоупотреблять переходами, иначе можно создать непрямое зацикливание. Принудительные переходы необходимы, если Вам нужно переключиться на другую ветку диалога, или вернуться на пару узлов обратно. Можно выполнить переходы сразу на несколько реплик одновременно, однако не стоит забывать об <a href="#head-kak_izbezhat_o4istki_spiska_deystviy" title="заголовок: Как избежать очистки списка действий">очистке списка действий и порядке его осуществления</a>.</p>
        <p>Для переходов по репликам используются следующие команды:</p>
        <div class="em_STEP">
            <p><span class="emTEXT">levelup:</span><span class="em_BLCK">##</span>   —   переход по узлам "назад". Вместо "решёток" указывается на сколько узлов нужно вернуться по репликам. Тип реплик при этом не учитывается. К примеру:</p>

            <p class="em_PF"><span class="emTEXT">   replics="repeat:cicle
   shuffle:random"
   npc="name:Ведущий:name
   ncolor:008888
   fcolor:008888"
   hero="name:Вася пупкин:name"
   {:<span class="em_MARKER">marker:firstqst</span>
   Как вас зовут?
      [:Меня зовут Вася.
         {:
            Вас зовут Вася?
            [:Да, меня зовут Вася.:]
            <span class="em_RED">[:Нет, никто меня так не зовёт
            <span class="emOPRT">levelup:5</span>:]</span>
         :}
         {:
            Это правда, что вас зовут Васей?
            [:Правда:]
            <span class="em_RED">[:Неправда
            <span class="emOPRT">levelup:3</span>:]</span>
         :}
      :]
      [:
         Меня зовут Петя.
         {:
            Вас зовут Петя?
            [:Да{:Как это удобно!:}:]
            [:Нет
               <span class="emOPRT">levelup:3</span>
               {:Вас зовут не Петя? Как неудобно!:}
            :]
         :}
         {:
            Это правда, что вас зовут Петей?
            [:Правда:]
            <span class="em_VIOL">[:Неправда
            <span class="emOPRT">leveljump:firstqst</span>:]</span>
         :}
         {:Неужели в самом деле Петей Вас зовут?
            [:В самом деле
            <span class="emOPRT">closeup</span>:]
            [:Нет, не в самом
            <span class="emOPRT">levelup:3</span>:]
         :}
      :]
   :}</span></p>
        <p>Здесь можно видеть несколько переходов по узлам, они выделены тёмно-голубым цветом. Сначала рассмотрим два из них.</p>
        <p>Реплика "Неправда" (подсвечена красным цветом) должна осуществлять переход на три узла назад. Она вложена в реплику "Это правда, что вас зовут Васей?", которую произнёс актёр. То есть это один уровень назад. Реплика "Это правда, что вас зовут Васей?" вложена в реплику "Меня зовут Вася", которую произнёс герой. Это два уровня назад. Эта реплика, в свою очередь, вложена в реплику неписи "Как вас зовут?". Она и будет репликой, на которую осуществится принудительный переход - три узла назад.</p>
        <p>Реплика "Нет, никто меня так не зовёт" (подсвечена синим цветом) должна осуществлять переход на пять узлов назад. Однако это невозможно, поскольку ей предшествовало всего четыре реплики, включая корневую. Переместиться на корневую реплику нельзя, поэтому будет осуществлено перемещение на реплику первого уровня "Как вас Зовут?".</p>
    </div>
    <div class="em_STEP">
        <p><span class="emTEXT">leveljump:</span><span class="em_BLCK">MARKER</span>   —   переход минуя все условия и промежуточные узлы на реплику с указанной меткой.</p>
        <p>Вместо "<span class="em_BLCK">MARKER</span>" указывается метка. Чтобы поставить метку на реплике, нужно использовать одиночный тег <span class="em_MARKER">marker:</span>, после которого следует прописать без пробелов любое сочетание символов (можно использовать только буквы и цифры и символ подчёркивания). Эти символы и будут меткой. Пример реплики, осуществляющей переход на метку, выделен фиолетовым цветом в предыдущем примере. Сама метка выделена жёлтым цветом.</p>
        <p>Если указанная в <span class="emTEXT">leveljump:</span> метка отсутствует, переход не осуществится.</p>
        <p>Чтобы осуществить переход сразу на несколько реплик, нужно указать для каждой из этих реплик одинаковые метки, а потом для реплики, с которой нужно перейти, указать команду <span class="emTEXT">leveljump:</span> и эту метку. Либо выставить для каждой реплики свою собственную метку, а потом прописать в реплике, с которой нужно перейти, команду <span class="emTEXT">leveljump:</span> столько раз на сколько реплик нужно перейти, с указанием каждой выставленной метки. Разница между двумя этими способами в том, что во втором случае Вы можете контролировать порядок вызова реплик. Вот оба варианта для сравнения:</p>
        <div class="em_CODE">
        <table class="em_plusBRD">
            <tr>
                <td>

<p class="em_PF">replics="repeat:cicle
shuffle:random"
npc="name:Ведущий:name
ncolor:008888
fcolor:008888"
hero="name:Вася пупкин:name"
{:<span class="em_MARKER">marker:firstqst</span>
Как вас зовут?
   [:
      Меня зовут Петя.
      {:
         Вас зовут Петя?
         [:Да{:Как это удобно!:}:]
         [:Нет
            <span class="emOPRT">levelup:3</span>
            {:Вас зовут не Петя? Как неудобно!:}
         :]
      :}
      {:
         Это правда, что вас зовут Петей?
         [:Правда:]
         <span class="em_VIOL">[:Неправда
         <span class="emOPRT">leveljump:firstqst</span>:]</span>
      :}
      {:Неужели в самом деле Петей Вас зовут?
        [:В самом деле
            <span class="emOPRT">closeup</span>
        :]
        [:Нет, не в самом
            <span class="emOPRT">levelup:3</span>
        :]
      :}
   :]
   [:
      {:А здесь у нас скрытая реплика
        <span class="em_MARKER">marker:firstqst</span>
      :}
   :]
:}</p>
                </td>
                <td>
                    <p class="em_PF">replics="repeat:cicle
shuffle:random"
npc="name:Ведущий:name
ncolor:008888
fcolor:008888"
hero="name:Вася пупкин:name"
{:<span class="em_MARKER">marker:firstqst</span>
   Как вас зовут?
   [:
      Меня зовут Петя.
      {:
         Вас зовут Петя?
         [:Да{:Как это удобно!:}:]
         [:Нет
            <span class="emOPRT">levelup:3</span>
            {:Вас зовут не Петя? Как неудобно!:}
         :]
      :}
      {:
         Это правда, что вас зовут Петей?
         [:Правда:]
         <span class="em_VIOL">[:Неправда
         <span class="emOPRT">leveljump:firstqst</span>
         <span class="emOPRT">leveljump:hidereplics</span>
         :]</span>
      :}
      {:Неужели в самом деле Петей Вас зовут?
         [:В самом деле
         <span class="emOPRT">closeup</span>:]
         [:Нет, не в самом
         <span class="emOPRT">levelup:3</span>:]
      :}
   :]
   [:
      {:А здесь у нас скрытая реплика
         <span class="em_MARKER">marker:hidereplics</span>
      :}
   :]
:}</p>
                </td>
            </tr>
        </table>
        </div>
        <P>В первом случае модуль сам отыщет первую реплику, которую выведет. Скорей всего это будет реплика с наивысшим уровнем. Во втором случае сначала будет осуществлён переход на реплику с меткой <span class="emARR">firstqst</span>, а затем на реплику с меткой <span class="emARR">hidereplics</span>. Т.е. именно в том порядке, в котором записаны команды <span class="emARR">leveljump:</span> в реплике "Неправда", выделенной фиолетовым цветом.</P>
    </div>
        <P>Чтобы принудительно закрыть диалог из реплики, нужно ввести команду <span class="emTEXT">closeup</span>. В последних примерах реплика "В самом деле" будет закрывать диалог. При закрытии диалога восстановится описание и действия локации, с которой диалог был вызван.</P>
        <h3>Названия действий</h3>
        <p>по умолчанию, в качестве названия действия выступает полный текст реплики. Это не всегда удобно. Иногда нужно вывести <i>очень</i> длинную реплику, полный текст которой будет смотреться неуместно в названии действия. На такой случай в модуле предусмотрена конструкция <span class="emTEXT">act-name:&nbsp;:act-name</span>. Текст, помещённый между этими двумя тегами, будет использоваться в качестве названия действия. Пример:</p>

        <p class="em_PF"><span class="emTEXT">   {:
      Как вас зовут?
      [:
      act-name:Вася:act-name
      Вообще моё имя - Василий. Но друзья зовут меня - Вася...
      :]
   :}</span></p>
        <P>В этом диалоге на экран сначала выведется реплика "Как вас зовут?" и действие с названием "Вася". При щелчке по действию, на экране появится реплика "Вообще моё имя - Василий. Но друзья зовут меня - Вася...".</P>
        <p>Всё довольно просто. Когда нам нужно вывести название действия, отличное от произносимой реплики, используем эту конструкцию.</p>
        <p>Эту же конструкцию следует использовать, если в узле действия Вы использовали конструкцию вывода блока фраз <span class="emTEXT">frase-block:&nbsp;:frase-block</span>. Однако здесь можно написать и обыкновенную реплику без тегов <span class="emTEXT">act-name:&nbsp;:act-name</span>, и она выведется в названии действия. Чтобы было понятнее, пример, когда в качестве названия действия выводится реплика:</p>

        <p class="em_PF"><span class="emTEXT">   {:
      Как вас зовут?
      [:
      Меня зовут Вася.
      :]
      [:
      Я стесняюсь...
      frase-block:
         &lt;hero-name&gt;Мне так неловко...
         &lt;npc-name&gt;Отчего же?
         &lt;hero-name&gt;Моё имя так необычно звучит...
         &lt;npc-name&gt;Ну же, смелее!
         &lt;hero-name&gt;Вартасахан Бздюльгахаев!
         &lt;hero-name&gt;Можно просто: Вася.
      :frase-block
      :]
   :}</span></p>
        <p>Пример, когда в качестве названия действия, будет выведен текст, помещённый между <span class="emTEXT">act-name:&nbsp;:act-name</span>:</p>

        <p class="em_PF"><span class="emTEXT">   {:
      Как вас зовут?
      [:
      act-name:Вася:act-name
      Меня зовут Вася.
      :]
      [:
      act-name:Мне неловко...:act-name
      Я стесняюсь...
      frase-block:
         &lt;hero-name&gt;Мне неловко...
         &lt;npc-name&gt;Отчего же?
         &lt;hero-name&gt;Моё имя так необычно звучит...
         &lt;npc-name&gt;Ну же, смелее!
         &lt;hero-name&gt;Вартасахан Бздюльгахаев!
         &lt;hero-name&gt;Можно просто: Вася.
      :frase-block
      :]
   :}</span></p>
        <p>Пример, когда название у действия будет, но реплику герой не произнесёт:</p>

        <p class="em_PF"><span class="emTEXT">   {:
      Как вас зовут?
      [:
      act-name:Вася:act-name
         {:npc="name::name"
         <i>
         Он бы мог сказать, что его зовут Вася. Но на самом деле его звали Вартасахан.
         </i>
         :}
      :]
   :}</span></p>
        <p>И напоследок. Блок фраз, который не появится в виде действия, потому что неоткуда извлечь название действия:</p>

        <p class="em_PF"><span class="emTEXT">   {:
      Как вас зовут?
      [:
      frase-block:
         &lt;hero-name&gt;Мне неловко...
         &lt;npc-name&gt;Отчего же?
         &lt;hero-name&gt;Моё имя так необычно звучит...
         &lt;npc-name&gt;Ну же, смелее!
         &lt;hero-name&gt;Вартасахан Бздюльгахаев!
         &lt;hero-name&gt;Можно просто: Вася.
      :frase-block
      :]
   :}</span></p>

        <h3>Комментирование реплик</h3>
        <p>Все реплики можно комментировать.</p>
        <p> Комментарии записываются так же, как записываются в обычном html-документе, т.е. внутри конструкции <span class="emCOMM">&lt;!--&nbsp;--&gt;</span>. Перед выводом реплик все подобные конструкции будут удалены.</p>
        <p> Комментарии главным образом предназначены для помещения в них настроек и прочих текстов, которые не должны входить в реплику. Конечно, настройки можно указывать и не в комментариях, но если разместить их внутри комментария, обработка каждой реплики сократится на несколько миллисекунд. При больших уровнях вложенности это может существенно сократить время вывода всех реплик на экран.</p><p> Все конструкции, расширяющие реплику, такие как <span class="emTEXT">frase-block:&nbsp;:frase-block</span>, <span class="emTEXT">act-name:&nbsp;:act-name</span>, <span class="emTEXT">iffing:&nbsp;:iffing</span>, и др., можно и нужно размещать в комментариях. Лучше всего всё это уместить в одном комментарии.</p>
        <p>Запрещено вкладывать комментарии в конструкции <span class="emTEXT">iffing:&nbsp;:iffing</span> и <span class="emTEXT">dynamic-code:&nbsp;:dynamic-code</span>, а так же вкладывать комментарии в комментарии. Вот пример неправильного размещения комментариев (подсвечены красным цветом):</p>

        <p class="em_PF"><span class="emTEXT">   <span class="emCOMM">&lt;!-- npc="
   name:Ведущий:name
   ncolor:008888<span class="em_RED">&lt;!-- цвет имени неписи --&gt;</span>
   fcolor:008888
   "
   hero="
   name:Вася Пупкин:name
   "
   --&gt;</span>
   {:
      Как вас зовут?
      [:

      hero="ncolor:008800"
         Меня зовут Вася.
         {:
         iffing:a=0<span class="em_RED">&lt;!-- реплика выводится, если "a" равно нулю --&gt;</span>:iffing
         dynamic-code:a=1:dynamic-code<span class="emCOMM">&lt;!-- изменяем значение "a", чтобы реплика больше не выводилась --&gt;</span>
         Вас зовут Вася?
            [:
            npc="fcolor:880000"
            Да, меня зовут Вася.
               {:да ну нафиг:}
               [:
               нет. чистая правда
               :]
            :]
            [:Нет, никто меня так не зовёт:]
         :}
         {:
         iffing:a>0:iffing<span class="emCOMM">&lt;!-- реплика выводится, если "a" больше нуля --&gt;</span>
         dynamic-code:if a&lt;5: a+=1<span class="em_RED">&lt;!-- изменяем значение "a", чтобы реплика больше не выводилась --&gt;</span>:dynamic-code
            Это правда, что вас зовут Васей?
            [:Правда
            :]
            [:Неправда:]
         :}
      :]
   :}</span></p>
        <p>Сами реплики в комментарии не помещаются.</p>
        <p>Если комментарий разместить, например, в блоке фраз, то он будет проигнорирован html-рендерером, поскольку написан по правилам комментариев в html.</p>
        <a id="easy_dialog_ingame"></a>
        <h2>Добавление диалогов в игру</h2>

        <p>Теперь, когда исходный текст диалога подготовлен, его нужно добавить в игру.

        <p>В первую очередь необходимо скопировать исходный текст (тело) диалога и присвоить его какой-нибудь переменной в игре. Я использую переменные, в названия которых включено слово <span class="emTEXT">"диалог"</span>:

        <p class="em_PF">   <span class="em_BLCK">$диалог<span class="emOPRT">[<span class="emTEXT">'пример'</span>]</span>=</span><span class="emTEXT">'npc="
         name:Ведущий:name
         ncolor:008888
         fcolor:008888
         "
         hero="
         name:Вася Пупкин:name
         "
         Это заголовок диалога. Его корень. Данные реплики будут выведены
         на экран как есть, без применения форматирования из настроек диалога.
         Тем не менее символы пробелов и табуляций перед строками, а также
         лишние переводы строк будут удалены.
         {:
            Как вас зовут?
            [:hero="ncolor:008800"
               Меня зовут Вася.
               {:Вас зовут Вася?
                  [:
                  npc="fcolor:880000"
                  Да, меня зовут Вася.
                     {:да ну нафиг:}
                     [:нет. чистая правда:]
                  :]
                  [:Нет, никто меня так не зовёт:]
               :}
               {:
                  Это правда, что вас зовут Васей?
                  [:Правда
                  :]
                  [:Неправда:]
               :}
            :]
            [:hero="ncolor:ff0000"
               Меня зовут Петя.
               {:
                  Вас зовут Петя?
                  [:Да{:Как это удобно!:}:]
                  [:Нет
                     {:Вас зовут не Петя? Как неудобно!:}
                  :]
               :}
               {:
                  Это правда, что вас зовут Петей?
                  [:Правда:]
                  [:Неправда:]
               :}
               {:Неужели в самом деле Петей Вас зовут?
                  [:В самом деле:]
                  [:Нет, не в самом:]
               :}
            :]
         :}'</span></p>
        <p>Теперь мы можем вызвать диалог в игре. Сделать это можно несколькими способами.

        <h3>Прямое воспроизведение</h3>

        <p>Это самый простой способ вызвать диалог в игре. Мы уже присвоили исходный текст переменной, теперь нам достаточно просто воспроизвести диалог. Для этого нужно воспользоваться интерпретатором диалогов, который уже встроен в модуль:
        <p class="em_CODE">
            <span class="emOPRT">gosub</span> <span class="emTEXT">'dialog.int'</span>,$диалог<span class="emOPRT">[<span class="emTEXT">'пример'</span>]</span>
        </p>
        <p>Здесь в качестве нулевого аргумента использован исходный текст диалога.

        <p>Однако, хотя этот способ и самый простой, он заметно подвешивает игру. Воспользуйтесь первой версией [http://] модуля, если вам подходит именно этот способ, и время воспроизведения диалога сократится вдвое.

        <p>Дело в том, что, если передавать исходный текст сразу интерпретатору, интерпретатор сначала преобразует исходный текст в удобную для воспроизведения форму, что требует времени. Тем не менее этот способ вполне подходит, если в игре у вас встречаются небольшие диалоги, которые нужно продемонстрировать лишь раз.

        <h3>Воспроизведение с предварительной генерацией диалога</h3>

        <p>Данный способ удобен, когда в игре создаётся много небольших диалогов, к которым игрок будет периодически возвращаться.

        <p>Первым делом диалог преобразуется в удобную для воспроизведения форму (таблица данных диалогов, или таблица объектов диалогов). Для этого применяется генератор диалогов, который встроен в модуль. Именно генерация отнимает много времени у плеера, поэтому в игре запускать генератор нужно заранее и желательно в том месте, где игрок тратит время на что-то иное, например, на чтение текста. Лучше всего запускать генератор на той локации, на которой диалог может впервые понадобиться, или за пару локаций до неё. Вот как вызывается генератор:
        <p class="em_CODE">
            <span class="emOPRT">gosub</span> <span class="emTEXT">'dialog.generate'</span>,$диалог<span class="emOPRT">[<span class="emTEXT">'пример'</span>]</span>,<span class="emTEXT">'уникальный_ID_диалога'</span>,<span class="emTEXT">''</span>
        </p>
        <P>Посмотрите. В качестве нулевого аргумента мы передаём исходный текст диалога, а в качестве первого аргумента — уникальный ID диалога. Для каждого диалога вам нужно придумать свой собственный ID (идентификатор). В качестве второго аргумента здесь передаётся пустое значение (можно не писать).

        <p>Генератор получит исходный текст диалога и преобразует его в удобную форму (таблица данных диалогов) и назначит ему в этой форме идентификатор. Для примера давайте дадим нашему диалогу идентификатор <span class="emTEXT">'диалог.с.васей'</span>. Вызов генератора тогда будет выглядеть так:
        <p class="em_CODE">
            <span class="emOPRT">gosub</span> <span class="emTEXT">'dialog.generate'</span>,$диалог<span class="emOPRT">[<span class="emTEXT">'пример'</span>]</span>,<span class="emTEXT">'диалог.с.васей'</span>
        </p>
        <p>Теперь, когда нам понадобится вызвать этот диалог на экран, мы обращаемся к интерпретатору следующим образом:
        <p class="em_CODE">
            <span class="emOPRT">gosub</span> <span class="emTEXT">'dialog.int'</span>,<span class="emTEXT">'диалог.с.васей'</span>
        </p>
        <p>Здесь в качестве нулевого аргумента использован идентификатор диалога. Интерпретатор сам поймёт, что вы ему передали: исходный текст, или идентификатор диалога.

        <p>Если вы неправильно укажете идентификатор диалога, экран плеера очистится, и ничего больше на нём не появится.

        <p>Этот способ, по сравнению с предыдущим, позволяет загружать диалог в десятки раз быстрее.

        <h3>воспроизведение диалогов, сгенерированных заранее</h3>

        <p>Этот способ хорош, когда требуется разместить в игре множество больших (сто-двести реплик) диалогов.

        <p>Генерация большого диалога будет заметно подвешивать игру, поэтому был придуман способ, когда вы заранее преобразуете исходный текст диалога в удобную форму, и добавляете в игру диалог уже в этой самой удобной форме — таблица данных.

        <p>Для того чтобы заранее сгенерировать диалог, нужно:</p>
        <ul>
            <li>создать отдельную игру на QSP, и подключить[http://] к ней модуль <span class="emCODE">easy.dialog</span>.</li>
            <li>присвоить (как мы уже делали) исходный текст диалога переменной</li>
            <li>вызвать генератор, указав последним аргументом управляющее слово <span class="emTEXT">'get.objs'</span>
                <p>Вот как бы выглядел вызов генератора в нашем случае:</p>
                <p class="em_CODE">
                    <span class="emOPRT">*pl</span> <span class="emFUNC">$func</span>(<span class="emTEXT">'dialog.generate'</span>,$диалог<span class="emOPRT">[<span class="emTEXT">'пример'</span>]</span>,<span class="emTEXT">'диалог.с.васей'</span>,<span class="emTEXT">'get.objs'</span>)
                </p>
                <br></li>
            <li>запустить игру в плеере версии 5.7.0 (классический Quest Soft Player)
                <p>При этом на экране появится готовый код таблицы данных. Выглядеть он будет примерно так:</p>

                <p class="em_PF"><span class="em_BLCK">      <span class="emCOMM">! REPLIC_0</span>
      $id_replic[]=<span class="emTEXT">'диалог.с.васей.ХtaKnDwТ'</span>
      $source_replic[]=<span class="emTEXT">'да ну нафиг&lt;!-- type-replic:quest --&gt;'</span>
      $sets_replic[]=<span class="emTEXT">'npc="(name:Ведущий:name)
      (ncolor:008888)
      (nattrib:-b)
      (fcolor:880000)
      (fattrib:)
      (tire: — )"
      hero="(name:Вася Пупкин:name)
      (ncolor:008800)
      (nattrib:-i-b)
      (fcolor:888888)
      (fattrib:-i)
      (tire: — )"
      replics="(repeat:cicle)
      (shuffle:straight)"'</span>
      kolvo_replic[]=<span class="emNUM">0</span>
      $position_replic[]=<span class="emTEXT">'диалог.с.васей.IщIQЮsфJ'</span>

      ...

      <span class="emCOMM">! REPLIC_22</span>
      $id_replic[]=<span class="emTEXT">'диалог.с.васей'</span>
      $source_replic[]=<span class="emTEXT">'npc="
      name:Ведущий:name
      ncolor:008888
      fcolor:008888
      "
      hero="
      name:Вася Пупкин:name
      "
      Это заголовок диалога. Его корень. Данные реплики будут выведены
      на экран как есть, без применения форматирования из настроек диалога.
      Тем не менее символы пробелов и табуляций перед строками, а также
      лишние переводы строк будут удалены.
      &lt;!-[count-tag:23]-!&gt;'</span>
      $sets_replic[]=<span class="emTEXT">'npc="(name:Ведущий:name)
      (ncolor:008888)
      (nattrib:-b)
      (fcolor:008888)
      (fattrib:)
      (tire: — )"
      hero="(name:Вася Пупкин:name)
      (ncolor:888888)
      (nattrib:-i-b)
      (fcolor:888888)
      (fattrib:-i)
      (tire: — )"
      replics="(repeat:cicle)
      (shuffle:straight)"'</span>
      kolvo_replic[]=<span class="emNUM">0</span>
      $position_replic[]=<span class="emTEXT">''</span>
      <span class="emCOMM">! диалог сгенерирован за 219 мсек.</span></span></p>
            </li>
            <li>этот код нужно полностью выделить и скопировать (нажимаем на клавиатуре клавиши <a class="emTOOL" title="Ctrl+C">Ctrl и C</a>)</li>
            <li>затем, переходим в игру, в которой мы собираемся разместить этот диалог и <a class="emTOOL" title="Ctrl+V">вставляем</a> полученный код на локацию, где диалог будет вызываться впервые (или за пару локаций до неё). Можно разместить все диалоги в виде таблицы данных на самой первой локации игры, но этого лучше не делать. Присвоение значений переменным тоже отнимает время у плеера.</li>
        </ul>
        <p>Всё. Заранее сгенерированный диалог вставлен в игру. Теперь плеер не будет тратить время на генерацию нескольких сотен реплик. Вызов диалога ничем не отличается от предыдущего способа — в том месте игры, где нам нужно вызвать диалог, пишем:</p>
        <p class="em_CODE">
            <span class="emOPRT">gosub</span> <span class="emTEXT">'dialog.int'</span>,<span class="emTEXT">'диалог.с.васей'</span>
        </p>
        <p>Время загузки диалога такое же, как и для предыдущего способа.

        <h3>Воспроизведение диалогов, сгенерированных заранее, и подгружаемых в процессе игры</h3>

        <p>Данный способ необходим тем, кто использует в игре диалоги намного большего размера, чем 100-200 реплик. Это гигантские диалоги.

        <p>Даже если заранее сформировать таблицу данных такого диалога, выполнение её кода будет заметно подвешивать игру, поэтому был придуман способ, как разнести выполнение кода во времени, чтобы оно было незаметно игроку.

        <p>К сожалению, данный способ не вполне автоматизирован и требует глубокого понимания структуры вашей игры и принципов работы QSP. Многие моменты придётся дописывать руками.

        <p>Как и в предыдущем способе, генерируем таблицу данных диалога заранее в отдельной игре, но вместо управляющего слова <span class="emTEXT">'get.objs'</span> используем управляющее слово <span class="emTEXT">'get.base'</span>:
        <p class="em_CODE">
            <span class="emOPRT">*pl</span> <span class="emFUNC">$func</span>(<span class="emTEXT">'dialog.generate'</span>,$диалог<span class="emOPRT">[<span class="emTEXT">'пример'</span>]</span>,<span class="emTEXT">'диалог.с.васей'</span>,<span class="emTEXT">'get.base'</span>)
        </p>
        <p>При этом формируется QSP-код таблицы данных диалога, немного отличающийся от кода в предыдущем способе:

        <p class="em_PF"><span class="em_BLCK">   <span class="em_MARKER">:DIALOG_0</span>
   <span class="emCOMM">! REPLIC_0</span>
   $id_replic[]=<span class="emTEXT">'диалог.с.васей.o84уИOоf'</span>
   $source_replic[]=<span class="emTEXT">'да ну нафиг&lt;!-- type-replic:quest --&gt;'</span>
   $sets_replic[]=<span class="emTEXT">'&lt;!-- ... --&gt;'</span>
   kolvo_replic[]=<span class="emNUM">0</span>
   $position_replic[]=<span class="emTEXT">'диалог.с.васей.ЧАёIIУTi'</span>
   <span class="emCOMM">! REPLIC_1</span>
   $id_replic[]=<span class="emTEXT">'диалог.с.васей.onIршobи'</span>
   $source_replic[]=<span class="emTEXT">'нет. чистая правда&lt;!-- type-replic:answer --&gt;'</span>
   $sets_replic[]=<span class="emTEXT">'&lt;!-- ... --&gt;'</span>
   kolvo_replic[]=<span class="emNUM">0</span>
   $position_replic[]=<span class="emTEXT">'диалог.с.васей.ЧАёIIУTi'</span>
   <span class="emCOMM">! REPLIC_2</span>
   ...
   <span class="emCOMM">! REPLIC_9</span>
   $id_replic[]=<span class="emTEXT">'диалог.с.васей.UьМYиIяЯ'</span>
   $source_replic[]=<span class="emTEXT">'Как это удобно!&lt;!-- type-replic:quest --&gt;'</span>
   $sets_replic[]=<span class="emTEXT">'&lt;!-- ... --&gt;'</span>
   kolvo_replic[]=<span class="emNUM">0</span>
   $position_replic[]=<span class="emTEXT">'диалог.с.васей.DАцvSGFr'</span>
   <span class="emOPRT">jump</span> <span class="emTEXT">'end_sel'</span>
   <span class="em_MARKER">:DIALOG_1</span>
   <span class="emCOMM">! REPLIC_10</span>
   $id_replic[]=<span class="emTEXT">'диалог.с.васей.DАцvSGFr'</span>
   $source_replic[]=<span class="emTEXT">'Да&lt;!-- type-replic:answer --&gt;'</span>
   $sets_replic[]=<span class="emTEXT">'&lt;!-- ... --&gt;'</span>
   kolvo_replic[]=<span class="emNUM">0</span>
   $position_replic[]=<span class="emTEXT">'диалог.с.васей.icМяКhнЁ'</span>
   <span class="emCOMM">! REPLIC_11</span>
   ...
   <span class="emCOMM">! REPLIC_19</span>
   $id_replic[]=<span class="emTEXT">'диалог.с.васей.TЦktргГL'</span>
   $source_replic[]=<span class="emTEXT">'Неужели в самом деле Петей Вас зовут?
   &lt;!-- type-replic:quest --&gt;'</span>
   $sets_replic[]=<span class="emTEXT">'&lt;!-- ... --&gt;'</span>
   kolvo_replic[]=<span class="emNUM">0</span>
   $position_replic[]=<span class="emTEXT">'диалог.с.васей.YuьcWhwK'</span>
   <span class="emOPRT">jump</span> <span class="emTEXT">'end_sel'</span>
   <span class="em_MARKER">:DIALOG_2</span>
   <span class="emCOMM">! REPLIC_20</span>
   $id_replic[]=<span class="emTEXT">'диалог.с.васей.YuьcWhwK'</span>
   $source_replic[]=<span class="emTEXT">'hero="ncolor:ff0000"
   Меня зовут Петя.
   &lt;!-- type-replic:answer --&gt;'</span>
   $sets_replic[]=<span class="emTEXT">'&lt;!-- ... --&gt;'</span>
   kolvo_replic[]=<span class="emNUM">0</span>
   $position_replic[]=<span class="emTEXT">'диалог.с.васей.1зEП7XA7'</span>
  <span class="emCOMM"> ! REPLIC_21</span>
   $id_replic[]=<span class="emTEXT">'диалог.с.васей.1зEП7XA7'</span>
   $source_replic[]=<span class="emTEXT">'Как вас зовут?
   &lt;!-- type-replic:quest --&gt;'</span>
   $sets_replic[]=<span class="emTEXT">'&lt;!-- ... --&gt;'</span>
   kolvo_replic[]=<span class="emNUM">0</span>
   $position_replic[]=<span class="emTEXT">'диалог.с.васей'</span>
   <span class="emCOMM">! REPLIC_22</span>
   $id_replic[]=<span class="emTEXT">'диалог.с.васей'</span>
   $source_replic[]=<span class="emTEXT">'npc="
   name:Ведущий:name
   ncolor:008888
   fcolor:008888
   "
   hero="
   name:Вася Пупкин:name
   "
   Это заголовок диалога. Его корень. Данные реплики будут выведены
   на экран как есть, без применения форматирования из настроек диалога.
   Тем не менее символы пробелов и табуляций перед строками, а также
   лишние переводы строк будут удалены.
   &lt;!-[count-tag:23]-!&gt;'</span>
   $sets_replic[]=<span class="emTEXT">'&lt;!-- ... --&gt;'</span>
   kolvo_replic[]=<span class="emNUM">0</span>
   $position_replic[]=<span class="emTEXT">''</span>
   <span class="emOPRT">jump</span> <span class="emTEXT">'end_sel'</span>
   <span class="emCOMM">! диалог сгенерирован за 246 мсек.</span></span></p>
        <p>Здесь опущены реплики и значения массива <span class="emARR">$sets_replic[]</span>, чтобы сократить запись.

        <p>Как видно, здесь код разбит на блоки с помощью меток типа <span class="em_MARKER">:DIALOG_##</span> и команды <span class="emOPRT">jump</span> <span class="emTEXT">'end_sel'</span>. Если у вас в игре будет несколько диалогов, старайтесь сделать генерацию заранее и в одной игре, чтобы номера меток не повторялись.

        <p>Теперь в игре, где у нас должны появиться эти диалоги делаем следующее:</p>
        <ul>
            <li>создаём локацию с названием <span class="emTEXT">'base.dialog'</span></li>
            <li>на локации <span class="emTEXT">'base.dialog'</span> вставляем сгенерированный код таблицы данных диалогов (если диалогов несколько — код всех диалогов, — и следим, чтобы нумерация меток шла по порядку и номера не повторялись).</li>
            <li>запоминаем номер последней метки на локации <span class="emNUM">+1</span> (например, если последняя метка <span class="em_MARKER">:DIALOG_22</span> — запоминаем <span class="emNUM">23</span>)</li>
            <li>добавляем строку в самом низу локации и пишем:
                <p class="em_CODE">
                    DIALOG_VALUE<span class="emOPRT">[<span class="emTEXT">'replics.counter'</span>]</span>+=<span class="emNUM">1</span>
                </p>
                <p>Эта строка будет увеличивать счётчик на единицу при каждом обращении к локации</p>
            </li>
            <li>добавляем строку в самом верху локации и пишем:
                <p class="em_CODE">
                    <span class="emOPRT">jump</span> <span class="emTEXT">'DIALOG_'</span>+<span class="emFUNC">str</span>(DIALOG_VALUE<span class="emOPRT">[<span class="emTEXT">'replics.counter'</span>]</span>)
                </p>
            </li>
            <li>создаём локацию <span class="emTEXT">"counter"</span>, либо работаем в уже созданной, не забывая присвоить соответствующее значение переменной $counter</li>
            <li>на локации <span class="emTEXT">"counter"</span> пишем строчку:
                <p class="em_CODE">
                    <span class="emOPRT">if</span> DIALOG_VALUE<span class="emOPRT">[<span class="emTEXT">'replics.counter'</span>]</span>&lt;<span class="emNUM">23</span>: <span class="emOPRT">gosub</span> <span class="emTEXT">'base.dialog'</span>
                </p>
            </li>
            <li> Вместо числа <span class="emNUM">23</span> пишем то число, которое запомнили.</li>
        </ul>
        <p>Теперь каждые пол секунды (или с другой частотой, в зависимости от настроек) плеер будет добавлять в таблицу данных 10 реплик из диалога. Таким образом в память плеера диалоги будут подгружаться незаметно для игрока, даже если они очень большие (гигантские). При воспроизведении диалога через интерпретатор (<span class="emOPRT">gosub</span> <span class="emTEXT">'dialog.int'</span>,<span class="emTEXT">'диалог.с.васей'</span>), он по-прежнему будет загружаться за несколько миллисекунд, как и в предыдущих двух случаях.

        <h5>Примечание:</h5>
        Если для добавления диалога в игру вы пользуетесь одним из двух последних способов, в самом начале игры создайте в таблице данных диалогов пустую реплику. Сделать это можно так:
        <p class="em_PF"><span class="em_BLCK">$id_replic[]=<span class="emTEXT">'DIALOGS'</span>
$source_replic[]=<span class="emTEXT">'&lt;dialogs&gt;'</span>
$sets_replic[]=<span class="emTEXT">''</span>
kolvo_replic[]=<span class="emNUM">0</span>
$position_replic[]=<span class="emTEXT">''</span></span></p>
        <h2>Заключение</h2>
        <p>Если Вы прочитали данное руководство залпом и составление диалогов для интерпретации модулем <span class="emFOLD">easy.dialog</span> показалось Вам слишком сложным, ознакомьтесь с другими возможностями составления диалогов в QSP. Чуть ниже даны ссылки на примеры от <span class="emTEXT">WladySpb</span> и <span class="emTEXT">y4ndexx</span>, а так же на пример реализации сложного диалога с помощью движка от <span class="emTEXT">Olegus.t.Gl</span>. Может быть Вам подойдёт что-нибудь из этого. Или перечитайте руководство ещё раз, и ознакомьтесь с примерами диалогов, составленных для модуля, в файле <span class="emFOLD">game.easy.dialog.qsp</span>, чтобы лучше усвоить как и что работает. Так же вы можете обратиться к составленному для <span class="emFOLD">easy.dialog</span> краткому описанию, где в общих чертах раскрываются термины, понятия, структуры и принципы конструирования диалогов.</p>
        <P>В тексте руководства использованы реплики из киносценариев и пьес разных авторов.</P>
        <p>Огромное спасибо <span class="emTEXT">WladySpb</span> и <span class="emTEXT">y4ndexx</span>, подготовившим <a href="http://qsp.su/index.php?option=com_content&view=article&id=72:-11&catid=36:2009-02-19-06-11-21&Itemid=76" title="перейти на QSP.su" target="new">примеры диалогов для QSP</a>, добавленные в официальные материалы для разработчиков. Они мне очень помогли, когда я только познакомился с QSP. А так же -  <span class="emTEXT">Olegus t.Gl</span> за реализацию "<a href="http://qsp.su/index.php?option=com_agora&task=topic&id=457&Itemid=57" target="new" title="перейти на QSP.su">диалога Чешира</a>", откуда я почерпнул немало идей и решений. Диалоги, реализованные в примерах, а так же "диалог Чешира", я постарался воспроизвести в примере использования модуля. Смотри файл "<span class="emTEXT">game.easy.dialog.qsp</span>" в архиве.</p>
        <h2>Содержание</h2>
        <ol class="em_ROME">
            <li>Подключение</li>
            <li>Простые диалоги</li>
            <li>Запуск диалога</li>
            <li>Настройки диалога
                <ol><li>Форматирование реплик</li>
                    <li>Наследование настроек</li>
                    <li>Сброс настроек</li>
                    <li>Порядок вывода реплик</li>
                </ol></li>
            <li>Чуть более сложные диалоги
                <ol>
                    <li>Корни, ветви и узлы</li>
                    <li>Скрытый узел</li>
                    <li>Ремарки
                        <ul><li>Ремарки внутри реплики</li></ul>
                    </li>
                    <li>Как избежать очистки списка действий
                        <ul><li>Удаление действия из списка</li></ul>
                    </li>
                    <li>Блок последовательных реплик</li>
                    <li>Реплики по условию</li>
                    <li>Выполнение кода при выводе реплики</li>
                    <li>Принудительные переходы по репликам. Закрытие диалога</li>
                    <li>Названия действий</li>
                    <li>Комментирование реплик</li>
                </ol>
            </li>
            <li>Добавление диалогов в игру
                <ol>
                    <li>Прямое воспроизведение</li>
                    <li>Воспроизведение с предварительной генерацией диалога</li>
                    <li>Воспроизведение диалогов, сгенерированных заранее</li>
                    <li>Воспроизведение диалогов, сгенерированных заранее, и подгружаемых в процессе игры</li>
                </ol>
            </li>
            <li>Заключение</li>
        </ol>
        <hr>
        <p>Примечания:</p>
        <p><a id="prim1" href="#backprim1" class="em_PRIM" title="Назад">[1]</a> Возможно так же написание с использованием одиночного апострофа: <span class="emTEXT">npc='&nbsp;' hero='&nbsp;' replics='&nbsp;'</span></p>

    </div>
    <div class="em_Epigraph">
        <div class="em_subText">
            <p>Aleks Versus'Easy Libraries'2019</p>
            <p>Aleks Versus'Game Adventure Making'Really Unimaginable Stories'2019</p>
        </div>
    </div>
</div>
</body>
</html>
